<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dice Combo ğŸ²</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; -webkit-tap-highlight-color: transparent; }
        
        body { 
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); 
            color: #fff; 
            min-height: 100vh; 
            padding: 8px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: flex-start; 
            overflow-x: hidden; 
            overflow-y: hidden; /* ç¦ç”¨æµè§ˆå™¨æ»šåŠ¨æ¡ */
        }
        
        .container { 
            max-width: 1000px; 
            width: 100%; 
            background: rgba(25, 25, 35, 0.95); 
            border-radius: 12px; 
            padding: 12px; 
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5); 
            border: 1px solid #2a2a3e; 
            margin-bottom: 8px; 
            position: relative;
            /* ä¿®æ”¹ï¼šé«˜åº¦å®Œå…¨è‡ªé€‚åº” */
            height: auto; /* é«˜åº¦è‡ªé€‚åº” */
            min-height: auto; /* æœ€å°é«˜åº¦è‡ªé€‚åº” */
            /* ä¿®æ”¹ï¼šç§»é™¤å†…éƒ¨æ»šåŠ¨ï¼Œè®©å†…å®¹è‡ªç„¶æ‰©å±• */
            overflow-y: visible; /* å†…å®¹å¯ä»¥è‡ªç„¶æ‰©å±• */
            /* æ·»åŠ ï¼šç¡®ä¿å®¹å™¨èƒ½æ‰©å±• */
            display: block;
        }
        
        .game-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; background: rgba(40, 40, 60, 0.7); border-radius: 10px; border: 1px solid #3a3a4e; overflow: hidden; min-height: 80px; padding-right: 8px; }
        
        .title-section { flex: 1; display: flex; flex-direction: column; justify-content: center; padding: 16px; background: linear-gradient(90deg, rgba(60, 60, 80, 0.8) 0%, rgba(40, 40, 60, 0.7) 100%); }
        
        .header-buttons { display: flex; gap: 8px; align-items: center; }
        
        .header-btn { background: linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%); color: #222; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-weight: bold; transition: all 0.2s ease; width: 44px; height: 44px; border-radius: 50%; font-size: 0.85rem; }
        
        .header-btn:hover { background: linear-gradient(135deg, #917cc1 0%, #ebb2db 100%); transform: scale(1.05); }
        
        .header-btn:active { transform: translateY(2px) scale(0.95); }
        
        .game-title { font-size: 1.6rem; font-weight: bold; color: #fff; display: flex; align-items: center; gap: 12px; margin-bottom: 4px; }
        
        .game-subtitle { font-size: 0.9rem; color: #ffd166; font-weight: bold; display: flex; align-items: center; gap: 6px; }
        
        .players-info { display: flex; justify-content: space-between; gap: 8px; margin-bottom: 8px; }
        
        .player-card { flex: 1; background: rgba(40, 40, 60, 0.8); border-radius: 8px; padding: 8px; border: 1px solid #3a3a4e; display: flex; align-items: center; justify-content: space-between; position: relative; }
        
        .player-card.player { border-color: #4ecdc4; }
        .player-card.ai { border-color: #ff6b6b; }
        
        .player-card.active-turn { box-shadow: 0 0 0 2px #ffd166, 0 0 15px rgba(255, 209, 102, 0.5); animation: pulse 2s infinite; }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 2px #ffd166, 0 0 15px rgba(255, 209, 102, 0.5); }
            50% { box-shadow: 0 0 0 4px #ffd166, 0 0 25px rgba(255, 209, 102, 0.8); }
            100% { box-shadow: 0 0 0 2px #ffd166, 0 0 15px rgba(255, 209, 102, 0.5); }
        }
        
        .player-left { flex: 1; }
        .player-right { display: flex; flex-direction: column; align-items: flex-end; justify-content: center; gap: 4px; }
        
        .player-card h2 { font-size: 0.8rem; margin-bottom: 8px; display: flex; align-items: center; gap: 4px; }
        
        .score { font-size: 1.5rem; font-weight: bold; line-height: 1; }
        
        .player-card.player .score { color: #4ecdc4; }
        .player-card.ai .score { color: #ff6b6b; }
        
        .round-score-left { font-size: 0.95rem; font-weight: bold; color: #ffd166; background: rgba(60, 60, 80, 0.8); padding: 3px 8px; border-radius: 4px; display: inline-block; line-height: 1; margin-top: 4px; }
        
        .game-area { 
            display: flex; 
            flex-direction: column; 
            gap: 12px; 
            margin-bottom: 12px; 
            position: relative; 
            /* ä¿®æ”¹ï¼šç§»é™¤å›ºå®šæœ€å°é«˜åº¦ */
            min-height: auto; /* ä»500pxæ”¹ä¸ºauto */
            /* æ·»åŠ ï¼šç¡®ä¿å†…å®¹èƒ½è‡ªç„¶æ‰©å±• */
            height: auto;
        }
        
        .dice-section { background: rgba(30, 30, 50, 0.8); padding: 12px; border-radius: 10px; border: 1px solid #3a3a5e; position: relative; }
        
        .round-info-bar { display: flex; justify-content: space-between; background: rgba(40, 40, 60, 0.9); padding: 10px 12px; border-radius: 8px; margin-bottom: 12px; border: 1px solid #3a3a4e; font-weight: bold; }
        
        .player-turn-round { border-color: #4ecdc4; border-width: 2px; background: rgba(78, 205, 196, 0.15); }
        .ai-turn-round { border-color: #ff6b6b; border-width: 2px; background: rgba(255, 107, 107, 0.15); }
        
        .round-display { font-size: 0.9rem; color: #fff; display: flex; align-items: center; gap: 6px; }
        
        .turn-indicator { font-size: 0.9rem; color: #ffd166; display: flex; align-items: center; gap: 6px; }
        
        .dice-container { display: flex; justify-content: center; gap: 8px; flex-wrap: nowrap; margin-bottom: 12px; overflow-x: auto; padding: 4px 0; }
        
        .dice-wrapper { display: flex; flex-direction: column; align-items: center; gap: 4px; flex-shrink: 0; }
        
        .dice { width: 58px; height: 58px; background: #fff; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 1.7rem; color: #222; box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3); cursor: pointer; transition: all 0.2s ease; position: relative; user-select: none; }
        
        .dice-label { font-size: 0.85rem; font-weight: bold; color: #ffd166; background: rgba(60, 60, 80, 0.8); padding: 2px 6px; border-radius: 4px; min-width: 22px; text-align: center; }
        
        .dice:hover { transform: translateY(-2px); box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4); }
        
        .dice.selected { background: #4ecdc4; color: white; transform: scale(1.05); }
        .dice.ai-selected { background: #ff6b6b; color: white; transform: scale(1.05); }
        .dice.used { background: #555; color: #777; cursor: not-allowed; opacity: 0.5; transform: scale(0.9); }
        .dice.locked { background: #888; color: #aaa; cursor: not-allowed; opacity: 0.7; }
        
        .dice.used::after { content: "Ã—"; position: absolute; top: -4px; right: -4px; background: #ff6b6b; color: white; width: 16px; height: 16px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.8rem; font-weight: bold; }
        
        .dice-points { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); width: 100%; height: 100%; padding: 5px; }
        
        .dot { width: 7px; height: 7px; background-color: #222; border-radius: 50%; justify-self: center; align-self: center; }
        
        .dice.selected .dot, .dice.ai-selected .dot { background-color: white; }
        .dice.used .dot { background-color: #777; }
        .dice.locked .dot { background-color: #aaa; }
        
        .dice-1 .dot:nth-child(1) { grid-column: 2; grid-row: 2; }
        .dice-2 .dot:nth-child(1) { grid-column: 1; grid-row: 1; }
        .dice-2 .dot:nth-child(2) { grid-column: 3; grid-row: 3; }
        .dice-3 .dot:nth-child(1) { grid-column: 1; grid-row: 1; }
        .dice-3 .dot:nth-child(2) { grid-column: 2; grid-row: 2; }
        .dice-3 .dot:nth-child(3) { grid-column: 3; grid-row: 3; }
        .dice-4 .dot:nth-child(1) { grid-column: 1; grid-row: 1; }
        .dice-4 .dot:nth-child(2) { grid-column: 3; grid-row: 1; }
        .dice-4 .dot:nth-child(3) { grid-column: 1; grid-row: 3; }
        .dice-4 .dot:nth-child(4) { grid-column: 3; grid-row: 3; }
        .dice-5 .dot:nth-child(1) { grid-column: 1; grid-row: 1; }
        .dice-5 .dot:nth-child(2) { grid-column: 3; grid-row: 1; }
        .dice-5 .dot:nth-child(3) { grid-column: 2; grid-row: 2; }
        .dice-5 .dot:nth-child(4) { grid-column: 1; grid-row: 3; }
        .dice-5 .dot:nth-child(5) { grid-column: 3; grid-row: 3; }
        .dice-6 .dot:nth-child(1) { grid-column: 1; grid-row: 1; }
        .dice-6 .dot:nth-child(2) { grid-column: 1; grid-row: 2; }
        .dice-6 .dot:nth-child(3) { grid-column: 1; grid-row: 3; }
        .dice-6 .dot:nth-child(4) { grid-column: 3; grid-row: 1; }
        .dice-6 .dot:nth-child(5) { grid-column: 3; grid-row: 2; }
        .dice-6 .dot:nth-child(6) { grid-column: 3; grid-row: 3; }
        
        .dice-question { display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; font-size: 1.7rem; font-weight: bold; color: #666; }
        
        @keyframes shake {
            0% { transform: translate(0, 0) rotate(0deg); }
            10% { transform: translate(-3px, -3px) rotate(-5deg); }
            20% { transform: translate(3px, 3px) rotate(5deg); }
            30% { transform: translate(-3px, 3px) rotate(-5deg); }
            40% { transform: translate(3px, -3px) rotate(5deg); }
            50% { transform: translate(-3px, -3px) rotate(-5deg); }
            60% { transform: translate(3px, 3px) rotate(5deg); }
            70% { transform: translate(-3px, 3px) rotate(-5deg); }
            80% { transform: translate(3px, -3px) rotate(5deg); }
            90% { transform: translate(-3px, -3px) rotate(-5deg); }
            100% { transform: translate(0, 0) rotate(0deg); }
        }
        
        .dice.shaking { animation: shake 0.5s ease-in-out; }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: scale(1); }
            40% { transform: scale(1.2); }
            60% { transform: scale(1.1); }
        }
        
        .dice.bounce { animation: bounce 0.6s ease; }
        
        .current-combination { background: rgba(40, 40, 60, 0.8); padding: 12px; border-radius: 8px; margin-top: 12px; border: 1px solid #3a3a5e; }
        
        .combination-title { font-size: 0.9rem; color: #ffd166; margin-bottom: 8px; display: flex; align-items: center; gap: 6px; }
        
        .combination-display { display: flex; flex-direction: column; gap: 6px; }
        
        .combination-item { display: flex; align-items: center; gap: 8px; padding: 6px; background: rgba(60, 60, 80, 0.6); border-radius: 5px; border-left: 3px solid #4ecdc4; font-size: 0.8rem; }
        
        .ai-combination-item { border-left: 3px solid #ff6b6b; }
        
        .combination-type { font-weight: bold; color: #4ecdc4; min-width: 60px; }
        .ai-combination-type { color: #ff6b6b; }
        
        .combination-values { font-size: 0.8rem; color: #fff; display: flex; align-items: center; gap: 5px; flex-wrap: wrap; }
        
        .combination-dice { display: inline-flex; align-items: center; justify-content: center; width: 26px; height: 26px; background: linear-gradient(135deg, #4ecdc4 0%, #a8e6cf 100%); border-radius: 4px; font-size: 0.9rem; font-weight: bold; color: #222; }
        .ai-combination-dice { background: linear-gradient(135deg, #ff6b6b 0%, #ff8e8e 100%); }
        
        .combination-score { margin-left: auto; font-weight: bold; color: #ffd166; font-size: 0.9rem; }
        
        .total-score { display: flex; justify-content: space-between; align-items: center; padding: 8px; background: rgba(60, 60, 80, 0.8); border-radius: 5px; margin-top: 8px; font-weight: bold; font-size: 1rem; border: 2px solid #ffd166; }
        
        .total-label { color: #fff; }
        .total-value { color: #ffd166; font-size: 1.1rem; }
        
        .controls { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 12px; }
        
        .control-btn { 
            padding: 10px 8px; 
            font-size: 0.85rem; 
            font-weight: bold; 
            border: none; 
            border-radius: 8px; 
            cursor: pointer; 
            transition: all 0.3s ease; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            gap: 5px; 
            text-align: center; 
            position: relative;
            overflow: hidden;
        }
        
        /* æŒ‰é’®å›å¼¹æ•ˆæœ */
        @keyframes buttonBounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-6px); }
            60% { transform: translateY(-3px); }
        }
        
        .control-btn.bounce { animation: buttonBounce 0.6s ease; }
        
        /* æŠ•æ·æŒ‰é’®å˜æš—æ•ˆæœ - ä½¿ç”¨åŠé€æ˜é®ç½© */
        #reroll-btn { 
            background: linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%); 
            color: #222; 
            transition: all 0.3s ease; 
        }
        #reroll-btn:hover:not(:disabled) { background: linear-gradient(135deg, #917cc1 0%, #ebb2db 100%); }
        #reroll-btn:disabled { 
            cursor: not-allowed; 
            position: relative;
        }
        
        /* æŠ•æ·æŒ‰é’®å˜æš—é®ç½© */
        #reroll-btn.darkened::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            z-index: 1;
        }
        
        #reroll-btn.darkened i,
        #reroll-btn.darkened span {
            position: relative;
            z-index: 2;
        }
        
        #score-btn { 
            background: linear-gradient(135deg, #4ecdc4 0%, #a8e6cf 100%); 
            color: #222; 
            transition: all 0.3s ease; 
        }
        #score-btn:hover:not(:disabled) { background: linear-gradient(135deg, #3dbdb4 0%, #98d6bf 100%); }
        
        /* ä¿®æ”¹æŒ‰é’®ç¦ç”¨çŠ¶æ€ */
        #reroll-btn:disabled:not(.darkened), #score-btn:disabled { 
            opacity: 1; 
            cursor: not-allowed; 
            transform: none !important; 
            box-shadow: none !important; 
        }
        #reroll-btn:disabled:not(.darkened) { 
            background: linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%); 
            color: #222; 
        }
        #score-btn:disabled { 
            background: linear-gradient(135deg, #4ecdc4 0%, #a8e6cf 100%); 
            color: #222; 
        }
        
        .collapsible { background: rgba(30, 30, 50, 0.8); border-radius: 10px; border: 1px solid #3a3a5e; margin-bottom: 8px; overflow: hidden; }
        
        .collapsible-header { padding: 10px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; background: rgba(40, 40, 60, 0.9); }
        
        .collapsible-header h3 { font-size: 1rem; margin: 0; color: #ddd; display: flex; align-items: center; gap: 6px; }
        
        .collapse-icon { transition: transform 0.3s ease; color: #ffd166; }
        
        .collapsible-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; }
        .collapsible-content.expanded { max-height: 200px; overflow-y: auto; }
        
        /* æ¸¸æˆæ—¥å¿—å­—ä½“è°ƒæ•´åˆ°å’Œè®¡åˆ†æŒ‰é’®ä¸€æ ·å¤§ */
        .game-log .log-content { 
            font-size: 0.85rem;  /* ä»0.7remæ”¹ä¸º0.85remï¼Œä¸è®¡åˆ†æŒ‰é’®ä¿æŒä¸€è‡´ */
            line-height: 1.3; 
            padding: 10px; 
            display: flex; 
            flex-direction: column-reverse; 
            max-height: 200px; 
            overflow-y: auto; 
        }
        
        .log-entry { padding: 5px; margin-bottom: 5px; border-radius: 5px; animation: fadeIn 0.5s ease; }
        
        .player-log { background: rgba(78, 205, 196, 0.1); border-left: 2px solid #4ecdc4; }
        .ai-log { background: rgba(255, 107, 107, 0.1); border-left: 2px solid #ff6b6b; }
        .system-log { background: rgba(255, 209, 102, 0.1); border-left: 2px solid #ffd166; }
        .warning-log { background: rgba(255, 107, 107, 0.15); border-left: 2px solid #ff6b6b; }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(3px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .overlay { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(0, 0, 0, 0.95); 
            display: none; 
            align-items: center; 
            justify-content: center; 
            z-index: 1000; 
            animation: fadeIn 0.3s ease; 
            padding: 16px; 
        }
        
        .modal-content { 
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); 
            padding: 20px; 
            border-radius: 12px; 
            text-align: left; 
            max-width: 800px; 
            width: 100%; 
            max-height: 70vh; 
            overflow-y: auto; 
            border: 2px solid #4ecdc4; 
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.7); 
            position: relative;
        }
        
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        
        .modal-title { font-size: 1.4rem; color: #ffd166; display: flex; align-items: center; gap: 10px; }
        
        .overlay-close-hint { 
            position: fixed; 
            bottom: 30px; 
            left: 50%; 
            transform: translateX(-50%); 
            color: rgba(255, 255, 255, 0.7); 
            font-size: 0.9rem; 
            text-align: center; 
            width: 100%; 
            padding: 10px; 
            z-index: 1001; 
        }
        
        .rules-section { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        .rules-section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        
        .rules-list { padding-left: 20px; margin-bottom: 10px; }
        .rules-list li { margin-bottom: 8px; position: relative; }
        .rules-list li::before { content: "â€¢"; color: #4ecdc4; font-weight: bold; position: absolute; left: -15px; }
        
        .rules-highlight { background: rgba(255, 209, 102, 0.15); padding: 12px; border-radius: 8px; border-left: 4px solid #ffd166; margin: 12px 0; }
        .rules-highlight-title { color: #ffd166; font-weight: bold; margin-bottom: 6px; display: flex; align-items: center; gap: 6px; }
        
        .rules-warning { background: rgba(255, 107, 107, 0.15); padding: 12px; border-radius: 8px; border-left: 4px solid #ff6b6b; margin: 12px 0; }
        .rules-warning-title { color: #ff6b6b; font-weight: bold; margin-bottom: 6px; display: flex; align-items: center; gap: 6px; }
        
        .rules-example { background: rgba(78, 205, 196, 0.1); padding: 10px; border-radius: 6px; margin: 8px 0; font-style: italic; border-left: 3px solid #4ecdc4; }
        
        .highlight { color: #ffd166; font-weight: bold; }
        .warning { color: #ff6b6b; font-weight: bold; }
        .important { color: #4ecdc4; font-weight: bold; }
        
        .history-table-container { margin-top: 15px; overflow-x: auto; }
        .history-table { width: 100%; border-collapse: separate; border-spacing: 0; font-size: 0.85rem; }
        
        .history-table th { background: rgba(60, 60, 80, 0.9); color: #ffd166; padding: 12px 8px; text-align: center; position: sticky; top: 0; z-index: 1; font-size: 0.9rem; border-bottom: 2px solid rgba(255, 209, 102, 0.3); }
        .history-table td { padding: 10px 8px; text-align: center; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        .history-table tr:last-child td { border-bottom: none; }
        .history-table tr:hover { background: rgba(255, 255, 255, 0.05); }
        
        .player-round { color: #4ecdc4; font-weight: bold; }
        .ai-round { color: #ff6b6b; font-weight: bold; }
        
        .round-combination { max-width: 200px; word-break: break-word; font-size: 0.8rem; line-height: 1.4; }
        
        /* æ–°å¢æ¸¸æˆç»“æŸå®¹å™¨ - æ›¿æ¢æ¸¸æˆåŒºåŸŸ - ä¿®æ”¹ä¸ºæ›´ç´§å‡‘ */
        .game-over-container { 
            display: none; 
            flex-direction: column; 
            background: rgba(30, 30, 50, 0.8); 
            padding: 18px; /* è°ƒæ•´ä¸ºæ›´åˆé€‚çš„é—´è· */
            border-radius: 10px; 
            border: 1px solid #3a3a5e; 
            height: 100%;
            justify-content: center;
            align-items: center;
            text-align: center;
            gap: 16px; /* å‡åŒ€é—´è· */
        }
        
        /* ç¬¬ä¸€è¡Œï¼šå¥–æ¯ + è·èƒœè€… */
        .game-over-winner { 
            font-size: 1.5rem; /* ä»1.8remæ”¹ä¸º1.5rem */
            font-weight: bold; 
            color: #ffd166; /* å¥–æ¯ä¸€æ å­—ä½“æ”¹ä¸ºé»„è‰² */
            display: flex; 
            align-items: center; 
            gap: 10px; 
            justify-content: center;
            margin-bottom: 4px; /* å‡å°‘é—´è· */
        }
        
        /* ç¬¬äºŒè¡Œï¼šæ¯”åˆ†æ ï¼Œä¸¤ç«¯æ·»åŠ ç©å®¶å’ŒAI */
        .game-over-score-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            width: 100%;
            margin-bottom: 8px;
        }
        
        .game-over-score-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            font-size: 1.1rem;
            width: 100%;
            max-width: 400px;
        }
        
        .score-label {
            font-weight: bold;
            font-size: 1.1rem;
            color: #fff;
            min-width: 60px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .player-label {
            color: #4ecdc4;
            justify-content: flex-start;
        }
        
        .ai-label {
            color: #ff6b6b;
            justify-content: flex-end;
        }
        
        .game-over-score { 
            display: flex; 
            justify-content: center; 
            align-items: center;
            gap: 8px; 
            font-size: 1.1rem;
            font-weight: bold;
            min-width: 180px;
        }
        
        .game-over-player-score { 
            color: #4ecdc4; 
            font-weight: bold;
            font-size: 1.3rem; /* ä»1.8remæ”¹ä¸º1.3rem */
            min-width: 60px;
            text-align: right;
        }
        
        .game-over-ai-score { 
            color: #ff6b6b; 
            font-weight: bold;
            font-size: 1.3rem; /* ä»1.8remæ”¹ä¸º1.3rem */
            min-width: 60px;
            text-align: left;
        }
        
        .game-over-score-separator {
            color: #ffd166;
            font-size: 1.3rem;
            font-weight: bold;
        }
        
        /* ç¬¬ä¸‰è¡Œï¼šå›åˆæ•° */
        .game-over-rounds {
            font-size: 1.1rem;
            color: #ffd166;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
            margin-bottom: 4px;
        }
        
        .game-over-rounds-value {
            color: #fff;
            font-weight: bold;
            font-size: 1.2rem;
        }
        
        /* ç¬¬å››éƒ¨åˆ†ï¼šç»Ÿè®¡é¡¹ */
        .game-over-stats { 
            margin-top: 8px;
            margin-bottom: 12px; /* å¢åŠ ç»Ÿè®¡é¡¹è¡¨æ ¼åº•éƒ¨å’Œå®¹å™¨å¤–è¾¹æ¡†çš„è·ç¦» */
            overflow-x: auto; 
            width: 100%;
            max-width: 500px;
        }
        
        .game-over-stats-table { 
            width: 100%; 
            border-collapse: collapse; 
            font-size: 0.95rem; /* ä»1remæ”¹ä¸º0.95rem */ 
            background: rgba(40, 40, 60, 0.8); 
            border-radius: 8px; 
            overflow: hidden; 
            border-spacing: 0;
        }
        
        .game-over-stats-table th { 
            background: rgba(60, 60, 80, 0.9); 
            color: #ffd166; 
            padding: 12px 10px; /* ä»12pxæ”¹ä¸º10px */ 
            text-align: center; 
            font-weight: bold; 
            border-bottom: 2px solid rgba(255, 255, 255, 0.1); 
        }
        
        .game-over-stats-table td { 
            padding: 12px 10px; /* ä»12pxæ”¹ä¸º10px */ 
            text-align: center; 
            border-bottom: 1px solid rgba(255, 255, 255, 0.1); 
        }
        
        .game-over-stats-table tr:last-child td { border-bottom: none; }
        .game-over-stats-table tr:hover { background: rgba(255, 255, 255, 0.05); }
        
        .player-stats-row td:first-child { color: #4ecdc4; font-weight: bold; }
        .ai-stats-row td:first-child { color: #ff6b6b; font-weight: bold; }
        .stats-value-cell { font-weight: bold; font-size: 1.1rem; /* ä»1.2remæ”¹ä¸º1.1rem */ }
        
        /* ç¬¬äº”éƒ¨åˆ†ï¼šé‡æ–°å¼€å§‹æŒ‰é’® */
        .game-over-restart-btn { 
            background: linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%); 
            color: #222; 
            font-size: 1rem; 
            padding: 12px 20px; /* ä»14px 24pxæ”¹ä¸º12px 20px */
            min-width: 180px; /* ä»200pxæ”¹ä¸º180px */
            border: none; 
            border-radius: 8px; 
            cursor: pointer; 
            transition: all 0.2s ease; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            gap: 10px; 
            font-weight: bold; 
            margin-top: 0px; /* å‡å°‘æŒ‰é’®ä¸Šæ–¹çš„é—´è· */
        }
        
        .game-over-restart-btn:hover { 
            background: linear-gradient(135deg, #917cc1 0%, #ebb2db 100%); 
            transform: scale(1.05);
        }
        
        .sound-control { 
            position: fixed; 
            bottom: 16px; 
            right: 16px; 
            width: 44px; 
            height: 44px; 
            border-radius: 50%; 
            background: rgba(40, 40, 60, 0.9); 
            color: #ffd166; 
            border: 1px solid #3a3a5e; 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 1.2rem; 
            z-index: 50; 
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3); 
            transition: all 0.3s ease;
        }
        .sound-control:hover { background: rgba(60, 60, 80, 0.9); }
        .sound-control.muted { color: #888; }
        
        /* æ–°å¢å·¦ä¸‹æ–¹åˆ†æ•°è¡¨æŒ‰é’® - æ”¹ä¸ºé•¿åœ†å½¢é»„åº•é»‘å­— */
        .score-control { 
            position: fixed; 
            bottom: 16px; 
            left: 16px; 
            background: #ffd166; /* é»„åº• */
            color: #222; /* é»‘å­— */
            border: none; 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-weight: bold; 
            font-size: 0.9rem; 
            z-index: 50; 
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3); 
            transition: all 0.3s ease;
            padding: 10px 16px;
            border-radius: 22px; /* é•¿åœ†å½¢ */
            min-width: 100px;
            height: 44px;
        }
        .score-control:hover { 
            background: #ffc145; 
            transform: scale(1.05); 
        }
        .score-control:active { 
            transform: translateY(2px) scale(0.95); 
        }
        
        .game-credit { 
            position: absolute; 
            bottom: 8px; 
            right: 12px; 
            font-size: 0.7rem; 
            color: rgba(255, 255, 255, 0.5); 
            text-align: right; 
            z-index: 1; 
        }
        
        /* åˆ†æ•°è¡¨å¼¹çª—æ ·å¼ - ç»Ÿä¸€å­—ä½“å¤§å° */
        .score-table-modal .modal-content {
            max-width: 450px;
            padding: 15px;
            max-height: 85vh;
        }
        
        .score-table-title {
            display: none;
        }
        
        .score-table {
            width: 100%;
            border-collapse: collapse;
            margin: 0;
            font-size: 1rem; /* ç»Ÿä¸€å­—ä½“å¤§å°ä¸º1rem */
        }
        
        .score-table th {
            background: rgba(60, 60, 80, 0.9);
            color: #ffd166;
            padding: 14px 10px;
            text-align: center;
            font-weight: bold;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 1rem; /* ç»Ÿä¸€å­—ä½“å¤§å° */
        }
        
        .score-table td {
            padding: 14px 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(40, 40, 60, 0.8);
            font-size: 1rem; /* ç»Ÿä¸€å­—ä½“å¤§å° */
        }
        
        .score-table tr:hover td {
            background: rgba(60, 60, 80, 0.9);
        }
        
        .score-table .combo-name {
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 1rem; /* ç»Ÿä¸€å­—ä½“å¤§å° */
        }
        
        .score-table .same-combo {
            color: #ff9a9e;
        }
        
        .score-table .sequence-combo {
            color: #4ecdc4;
        }
        
        .score-table .score-value {
            color: #ffd166;
            font-weight: bold;
            font-size: 1rem; /* ä»1.1remæ”¹ä¸º1remï¼Œä¸ç»„åˆåç§°ä¿æŒä¸€è‡´ */
        }
        
        .score-note {
            display: none;
        }
        
        /* å“åº”å¼è®¾è®¡ä¼˜åŒ– - æ‰‹æœºç«¯ç©å®¶å’ŒAIå·¦å³å¹¶åˆ— */
        @media (max-width: 768px) {
            body {
                overflow-y: hidden; /* ç§»åŠ¨ç«¯ä¹Ÿç¦ç”¨æ»šåŠ¨ */
            }
            
            .container { 
                padding: 10px; 
                /* ç§»åŠ¨ç«¯ä¹Ÿä¿æŒè‡ªé€‚åº” */
                height: auto;
                min-height: auto;
                overflow-y: visible;
            }
            
            .game-title { font-size: 1.4rem; }
            .game-subtitle { font-size: 0.8rem; }
            .players-info { flex-direction: row; }
            .player-card { width: 100%; }
            .dice { width: 46px; height: 46px; font-size: 1.5rem; }
            .dice-question { font-size: 1.5rem; }
            .dice-points { padding: 4px; }
            .dot { width: 6px; height: 6px; }
            .dice-label { font-size: 0.8rem; padding: 1px 4px; min-width: 20px; }
            .dice-container { gap: 6px; }
            .dice-wrapper { gap: 2px; }
            .control-btn { font-size: 0.8rem; padding: 8px 6px; }
            .header-btn { width: 40px; height: 40px; font-size: 0.75rem; }
            .game-over-container { 
                padding: 14px; /* è°ƒæ•´ä¸ºæ›´ç´§å‡‘çš„é—´è· */
                gap: 12px; /* ä»15pxæ”¹ä¸º12px */
            }
            .game-over-winner { 
                font-size: 1.3rem; /* ä»1.5remæ”¹ä¸º1.3rem */
                margin-bottom: 2px;
            }
            .game-over-score-section {
                gap: 6px;
                margin-bottom: 4px;
            }
            .game-over-score-row {
                font-size: 1rem;
                gap: 8px;
            }
            .score-label {
                font-size: 1rem;
                min-width: 50px;
                gap: 4px;
            }
            .game-over-score {
                font-size: 1rem;
                gap: 6px;
                min-width: 150px;
            }
            .game-over-player-score,
            .game-over-ai-score {
                font-size: 1.1rem; /* ä»1.3remæ”¹ä¸º1.1rem */
                min-width: 50px;
            }
            .game-over-score-separator {
                font-size: 1.1rem; /* ä»1.2remæ”¹ä¸º1.1rem */
            }
            .game-over-rounds {
                font-size: 1rem;
                margin-bottom: 2px;
            }
            .game-over-rounds-value {
                font-size: 1.1rem;
            }
            .round-score-left { font-size: 0.9rem; padding: 2px 6px; }
            .round-display, .turn-indicator { font-size: 0.8rem; }
            .modal-content { padding: 15px; max-height: 60vh; }
            .modal-title { font-size: 1.2rem; }
            .overlay-close-hint { font-size: 0.8rem; bottom: 20px; }
            .history-table { font-size: 0.75rem; }
            .history-table th, .history-table td { padding: 8px 4px; }
            .round-combination { max-width: 120px; }
            .sound-control { width: 40px; height: 40px; font-size: 1rem; }
            .score-control { 
                width: auto; 
                height: 40px; 
                font-size: 0.8rem; 
                padding: 8px 14px; 
                min-width: 90px; 
                border-radius: 20px; 
            }
            .game-over-restart-btn { 
                min-width: 160px; /* ä»180pxæ”¹ä¸º160px */
                padding: 10px 16px; /* ä»12px 20pxæ”¹ä¸º10px 16px */
                font-size: 0.9rem;
                margin-top: 8px; /* è¿›ä¸€æ­¥å‡å°‘æŒ‰é’®ä¸Šæ–¹çš„é—´è· */
            }
            .rules-section-title { font-size: 1rem; }
            .rules-content { font-size: 0.85rem; }
            .game-header { min-height: 70px; }
            .title-section { padding: 12px; }
            .score-table { font-size: 0.9rem; } /* ç§»åŠ¨ç«¯è°ƒæ•´ä¸º0.9rem */
            .score-table th, .score-table td { padding: 10px 6px; }
            .score-table .combo-name, .score-table .score-value { font-size: 0.9rem; } /* ç§»åŠ¨ç«¯ç»Ÿä¸€è°ƒæ•´ */
            .game-log .log-content { font-size: 0.75rem; } /* ç§»åŠ¨ç«¯æ—¥å¿—å­—ä½“è°ƒå°ä¸€ç‚¹ */
            .game-over-stats-table { font-size: 0.85rem; } /* ç§»åŠ¨ç«¯ç»Ÿè®¡è¡¨æ ¼å­—ä½“æ›´å° */
            .game-over-stats-table th,
            .game-over-stats-table td { padding: 10px 8px; } /* ç§»åŠ¨ç«¯è¡¨æ ¼å†…è¾¹è·è°ƒæ•´ */
            .stats-value-cell { font-size: 1rem; } /* ç§»åŠ¨ç«¯ç»Ÿè®¡æ•°å€¼å­—ä½“æ›´å° */
        }
        
        @media (max-width: 480px) {
            .dice { width: 42px; height: 42px; font-size: 1.4rem; }
            .dice-question { font-size: 1.4rem; }
            .dot { width: 5px; height: 5px; }
            .dice-container { gap: 4px; }
            .game-header { min-height: auto; padding-right: 8px; }
            .title-section { padding: 10px; }
            .header-buttons { gap: 6px; }
            .header-btn { width: 38px; height: 38px; font-size: 0.7rem; }
            .round-score-left { font-size: 0.85rem; padding: 2px 4px; }
            .history-table { font-size: 0.7rem; }
            .history-table th, .history-table td { padding: 6px 3px; }
            .round-combination { max-width: 100px; }
            .overlay-close-hint { font-size: 0.75rem; bottom: 15px; }
            .players-info { gap: 6px; }
            .player-card { padding: 6px; }
            .game-over-container { 
                padding: 12px; /* è°ƒæ•´ä¸ºæ›´ç´§å‡‘çš„é—´è· */
                gap: 10px;
            }
            .game-over-winner { 
                font-size: 1.1rem; /* ä»1.3remæ”¹ä¸º1.1rem */
                margin-bottom: 0;
            }
            .game-over-score-section {
                gap: 4px;
                margin-bottom: 2px;
            }
            .game-over-score-row {
                font-size: 0.9rem;
                gap: 6px;
            }
            .score-label {
                font-size: 0.9rem;
                min-width: 45px;
                gap: 3px;
            }
            .game-over-score {
                font-size: 0.9rem;
                gap: 4px;
                min-width: 130px;
            }
            .game-over-player-score,
            .game-over-ai-score {
                font-size: 1rem; /* ä»1.1remæ”¹ä¸º1rem */
                min-width: 45px;
            }
            .game-over-score-separator {
                font-size: 1rem;
            }
            .game-over-rounds {
                font-size: 0.9rem;
                margin-bottom: 0;
            }
            .game-over-rounds-value {
                font-size: 1rem;
            }
            .score-table { font-size: 0.85rem; } /* æ›´å°çš„å±å¹•è°ƒæ•´ä¸º0.85rem */
            .score-table th, .score-table td { padding: 8px 4px; }
            .score-table .combo-name, .score-table .score-value { font-size: 0.85rem; } /* ç»Ÿä¸€è°ƒæ•´ */
            .sound-control { width: 36px; height: 36px; font-size: 0.9rem; }
            .score-control { 
                width: auto; 
                height: 36px; 
                font-size: 0.75rem; 
                padding: 6px 12px; 
                min-width: 80px; 
                border-radius: 18px; 
            }
            .game-log .log-content { font-size: 0.7rem; } /* æ›´å°çš„å±å¹•æ—¥å¿—å­—ä½“å†å°ä¸€ç‚¹ */
            .game-over-stats-table { font-size: 0.8rem; } /* æ›´å°çš„å±å¹•ç»Ÿè®¡è¡¨æ ¼å­—ä½“æ›´å° */
            .game-over-stats-table th,
            .game-over-stats-table td { padding: 8px 6px; } /* æ›´å°çš„å±å¹•è¡¨æ ¼å†…è¾¹è·è°ƒæ•´ */
            .stats-value-cell { font-size: 0.9rem; } /* æ›´å°çš„å±å¹•ç»Ÿè®¡æ•°å€¼å­—ä½“æ›´å° */
            .game-over-restart-btn { 
                min-width: 140px; /* ä»160pxæ”¹ä¸º140px */
                padding: 8px 14px; /* ä»10px 16pxæ”¹ä¸º8px 14px */
                font-size: 0.85rem;
                margin-top: 6px; /* è¿›ä¸€æ­¥å‡å°‘æŒ‰é’®ä¸Šæ–¹çš„é—´è· */
            }
        }
        
        /* PCç«¯éª°å­æ›´å¤§ */
        @media (min-width: 769px) {
            .dice { width: 62px; height: 62px; font-size: 1.9rem; }
            .dice-question { font-size: 1.9rem; }
            .dice-points { padding: 7px; }
            .dot { width: 8px; height: 8px; }
        }
        
        .log-content::-webkit-scrollbar, .modal-content::-webkit-scrollbar { width: 6px; }
        .log-content::-webkit-scrollbar-track, .modal-content::-webkit-scrollbar-track { background: rgba(60, 60, 80, 0.5); border-radius: 3px; }
        .log-content::-webkit-scrollbar-thumb, .modal-content::-webkit-scrollbar-thumb { background: #ffd166; border-radius: 3px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="game-header">
            <div class="title-section">
                <div class="game-title">Dice Combo ğŸ²</div>
                <div class="game-subtitle"><i class="fas fa-bullseye"></i> ç›®æ ‡åˆ†æ•°: <span id="target-score">500</span></div>
            </div>
            <div class="header-buttons">
                <button class="header-btn" id="rules-button" title="æ¸¸æˆè§„åˆ™">
                    <i class="fas fa-book"></i>
                </button>
                <button class="header-btn" id="history-button" title="å†å²è®°å½•">
                    <i class="fas fa-history"></i>
                </button>
            </div>
        </div>
        
        <div class="players-info">
            <div class="player-card player" id="player-card">
                <div class="player-left">
                    <h2><i class="fas fa-user"></i> ç©å®¶</h2>
                    <div class="round-score-left" id="player-round-score-left">æœ¬å›åˆ: 0</div>
                </div>
                <div class="player-right">
                    <div class="score-container">
                        <div class="score player-score">0</div>
                    </div>
                </div>
            </div>
            
            <div class="player-card ai" id="ai-card">
                <div class="player-left">
                    <h2><i class="fas fa-robot"></i> AIå¯¹æ‰‹</h2>
                    <div class="round-score-left" id="ai-round-score-left">æœ¬å›åˆ: 0</div>
                </div>
                <div class="player-right">
                    <div class="score-container">
                        <div class="score ai-score">0</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="game-area">
            <div class="dice-section">
                <!-- ä¿®æ”¹å›åˆä¿¡æ¯æ˜¾ç¤º -->
                <div class="round-info-bar" id="round-info-bar">
                    <div class="round-display">
                        <i class="fas fa-flag"></i> ç¬¬<span id="round-number">1</span>å›åˆ
                    </div>
                    <div class="turn-indicator" id="turn-indicator-text">
                        <i class="fas fa-user"></i> ç©å®¶å›åˆ
                    </div>
                </div>
                
                <div class="dice-container" id="dice-container"></div>
                
                <div class="current-combination" id="current-combination">
                    <h3 class="combination-title" id="combination-title"><i class="fas fa-list-ol"></i> å½“å‰ç»„åˆåˆ†æ</h3>
                    <div class="combination-display" id="combination-display"></div>
                    <div class="total-score" id="total-score-display">
                        <div class="total-label">æ€»è®¡å¾—åˆ†:</div>
                        <div class="total-value" id="total-score-value">0</div>
                    </div>
                </div>
                
                <div class="controls">
                    <button id="reroll-btn" class="control-btn" disabled>
                        <i class="fas fa-redo"></i> æŠ•æ· (é€‰3+éª°å­)
                    </button>
                    <button id="score-btn" class="control-btn" disabled>
                        <i class="fas fa-flag-checkered"></i> è®¡åˆ†
                    </button>
                </div>
            </div>
            
            <!-- ä¿®æ”¹æ¸¸æˆç»“æŸå®¹å™¨ç»“æ„ -->
            <div class="game-over-container" id="game-over-container">
                <!-- ç¬¬ä¸€è¡Œï¼šå¥–æ¯ + è·èƒœè€… -->
                <div class="game-over-winner" id="game-over-winner">
                    <i class="fas fa-trophy"></i><span id="winner-text">ç©å®¶è·èƒœ</span><i class="fas fa-trophy"></i>
                </div>
                
                <!-- ç¬¬äºŒè¡Œï¼šæ¯”åˆ†æ ï¼Œä¸¤ç«¯æ·»åŠ ç©å®¶å’ŒAI -->
                <div class="game-over-score-section">
                    <div class="game-over-score-row">
                        <div class="score-label player-label">
                            <i class="fas fa-user"></i> ç©å®¶
                        </div>
                        <div class="game-over-score">
                            <span class="game-over-player-score" id="game-over-player-score">0</span>
                            <span class="game-over-score-separator">-</span>
                            <span class="game-over-ai-score" id="game-over-ai-score">0</span>
                        </div>
                        <div class="score-label ai-label">
                            AI <i class="fas fa-robot"></i>
                        </div>
                    </div>
                </div>
                
                <!-- ç¬¬ä¸‰è¡Œï¼šå›åˆæ•° -->
                <div class="game-over-rounds" id="game-over-rounds">
                    <span>å›åˆæ•°:</span>
                    <span class="game-over-rounds-value" id="game-over-round-number">1</span>
                </div>
                
                <!-- ç¬¬å››éƒ¨åˆ†ï¼šç»Ÿè®¡é¡¹ -->
                <div class="game-over-stats">
                    <table class="game-over-stats-table">
                        <thead>
                            <tr>
                                <th>ç»Ÿè®¡é¡¹</th>
                                <th>ç©å®¶</th>
                                <th>AIå¯¹æ‰‹</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr class="player-stats-row">
                                <td>å¹³å‡æ¯å›åˆå¾—åˆ†</td>
                                <td class="stats-value-cell" id="game-over-player-avg">0</td>
                                <td class="stats-value-cell" id="game-over-ai-avg">0</td>
                            </tr>
                            <tr class="ai-stats-row">
                                <td>æœ€é«˜å•å›åˆå¾—åˆ†</td>
                                <td class="stats-value-cell" id="game-over-player-max">0</td>
                                <td class="stats-value-cell" id="game-over-ai-max">0</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <!-- ç¬¬äº”éƒ¨åˆ†ï¼šé‡æ–°å¼€å§‹æŒ‰é’® -->
                <button id="game-over-restart-btn" class="game-over-restart-btn">
                    <i class="fas fa-redo"></i> é‡æ–°å¼€å§‹æ¸¸æˆ
                </button>
            </div>
            
            <div class="collapsible" id="game-log-collapsible">
                <div class="collapsible-header" onclick="toggleCollapse('game-log')">
                    <h3><i class="fas fa-scroll"></i> æ¸¸æˆæ—¥å¿—</h3>
                    <i class="fas fa-chevron-down collapse-icon" id="game-log-icon"></i>
                </div>
                <div class="collapsible-content" id="game-log-content">
                    <div class="log-content" id="log-content">
                        <div class="log-entry system-log">
                            æ¸¸æˆå¼€å§‹ï¼ä½ æ˜¯å…ˆæ‰‹ã€‚ç­‰å¾…éª°å­æŠ•æ·...
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- æ¸¸æˆç‰ˆæƒä¿¡æ¯ -->
        <div class="game-credit">A game by Wes</div>
    </div>
    
    <!-- å·¦ä¸‹æ–¹åˆ†æ•°è¡¨æŒ‰é’® -->
    <button class="score-control" id="score-control">
        <i class="fas fa-star"></i> åˆ†æ•°è¡¨
    </button>
    
    <!-- å³ä¸‹æ–¹éŸ³é‡å¼€å…³ -->
    <button class="sound-control" id="sound-control">
        <i class="fas fa-volume-up"></i>
    </button>
    
    <!-- åˆ†æ•°è¡¨å¼¹çª— -->
    <div class="overlay score-table-modal" id="score-table-overlay">
        <div class="modal-content" id="score-table-modal-content">
            <div class="score-table-container">
                <table class="score-table">
                    <thead>
                        <tr>
                            <th>ç»„åˆç±»å‹</th>
                            <th>å¾—åˆ†</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td class="combo-name same-combo">
                                <i class="fas fa-layer-group"></i> 2å 
                            </td>
                            <td class="score-value">10</td>
                        </tr>
                        <tr>
                            <td class="combo-name sequence-combo">
                                <i class="fas fa-stream"></i> 3è¿
                            </td>
                            <td class="score-value">20</td>
                        </tr>
                        <tr>
                            <td class="combo-name same-combo">
                                <i class="fas fa-layer-group"></i> 3å 
                            </td>
                            <td class="score-value">40</td>
                        </tr>
                        <tr>
                            <td class="combo-name same-combo">
                                <i class="fas fa-layer-group"></i> 4è¿
                            </td>
                            <td class="score-value">60</td>
                        </tr>
                        <tr>
                            <td class="combo-name sequence-combo">
                                <i class="fas fa-stream"></i> 4å 
                            </td>
                            <td class="score-value">80</td>
                        </tr>
                        <tr>
                            <td class="combo-name sequence-combo">
                                <i class="fas fa-stream"></i> 5è¿
                            </td>
                            <td class="score-value">100</td>
                        </tr>
                        <tr>
                            <td class="combo-name sequence-combo">
                                <i class="fas fa-stream"></i> 6è¿
                            </td>
                            <td class="score-value">140</td>
                        </tr>
                        <tr>
                            <td class="combo-name same-combo">
                                <i class="fas fa-layer-group"></i> 5å 
                            </td>
                            <td class="score-value">180</td>
                        </tr>
                        <tr>
                            <td class="combo-name same-combo">
                                <i class="fas fa-layer-group"></i> 6å 
                            </td>
                            <td class="score-value">320</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        <!-- ç‚¹å‡»ç©ºç™½å¤„è¿”å›æç¤º -->
        <div class="overlay-close-hint" id="score-table-close-hint">ç‚¹å‡»ç©ºç™½å¤„è¿”å›</div>
    </div>
    
    <div class="overlay" id="rules-overlay">
        <div class="modal-content" id="rules-modal-content">
            <div class="modal-header">
                <h2 class="modal-title"><i class="fas fa-book"></i> æ¸¸æˆè§„åˆ™</h2>
            </div>
            <div class="rules-content">
                <div class="rules-section">
                    <h3 class="rules-section-title"><i class="fas fa-gamepad"></i> æ ¸å¿ƒæ“ä½œ</h3>
                    <ul class="rules-list">
                        <li>æ¯å›åˆè‡ªåŠ¨æŠ•æ·éª°å­ï¼Œ<span class="important">å¿…é¡»æŒ‰ç‚¹æ•°ä»å°åˆ°å¤§çš„é¡ºåº</span>ç‚¹å‡»éª°å­è¿›è¡Œé€‰æ‹©</li>
                        <li>å†æ¬¡ç‚¹å‡»å·²é€‰éª°å­ï¼Œå¯å–æ¶ˆé€‰æ‹©</li>
                    </ul>
                </div>
                
                <div class="rules-section">
                    <h3 class="rules-section-title"><i class="fas fa-calculator"></i> åˆ†ç»„ä¸è®¡åˆ†</h3>
                    <ul class="rules-list">
                        <li><span class="highlight">ç³»ç»Ÿè‡ªåŠ¨åˆ†ç»„ï¼š</span></li>
                        <li><span class="important">è‡³å°‘3ä¸ª</span>è¿ç»­é€‰æ‹©çš„ <span class="important">"è¿ç»­ç‚¹æ•°"</span> = è¿ç»­æ•°</li>
                        <li><span class="important">è‡³å°‘2ä¸ª</span>è¿ç»­é€‰æ‹©çš„ <span class="important">"ç›¸åŒç‚¹æ•°"</span> = å æ•°</li>
                        <li><span class="important">ä¼˜å…ˆçº§ï¼š</span>å…ˆç‚¹å‡»çš„ç‚¹æ•°ä¼˜å…ˆæˆç»„</li>
                        <li>æ ¹æ®ç»„åˆç±»å‹è®¡åˆ†ï¼Œå…·ä½“åˆ†æ•°è¯·æŸ¥çœ‹<span class="important">åˆ†æ•°è¡¨</span</li>
                    </ul>
                </div>
                
                <div class="rules-section">
                    <h3 class="rules-section-title"><i class="fas fa-play-circle"></i> æŒ‰é’®åŠŸèƒ½</h3>
                    <ul class="rules-list">
                        <li><span class="important">ã€æŠ•æ·ã€ï¼š</span>é‡æŠ•å·²é€‰å®šçš„3ä¸ªæˆ–ä»¥ä¸Šéª°å­ï¼Œæ¯å›åˆåªèƒ½ä½¿ç”¨ä¸€æ¬¡</li>
                        <li><span class="important">ã€è®¡åˆ†ã€ï¼š</span>å½“å‰ç»„åˆè®¡åˆ†ï¼Œç»“æŸæœ¬å›åˆ</li>
                    </ul>
                </div>
                                
                <div class="rules-section">
                    <h3 class="rules-section-title"><i class="fas fa-flag-checkered"></i> æ¸¸æˆèƒœåˆ©æ¡ä»¶</h3>
                    <div class="rules-highlight">
                        <div class="rules-highlight-title"><i class="fas fa-trophy"></i> èƒœè´Ÿåˆ¤å®š</div>
                        <ul class="rules-list">
                            <li>ç©å®¶ä¸AIè½®æµè¿›è¡Œå›åˆï¼Œæ„æˆä¸€ä¸ªå®Œæ•´å›åˆ</li>
                            <li>å½“ä¸€ä¸ªå®Œæ•´å›åˆç»“æŸæ—¶ï¼Œè‹¥<span class="important">ä»»ä½•ä¸€æ–¹çš„ç´¯è®¡åˆ†æ•°è¾¾åˆ°æˆ–è¶…è¿‡500åˆ†</span>ï¼Œåˆ™æ¸¸æˆç»“æŸ</li>
                            <li><span class="important">åˆ†æ•°é«˜è€…è·èƒœ</span>ï¼Œè‹¥åˆ†æ•°ç›¸åŒï¼Œåˆ™ä¸º<span class="important">å¹³å±€</span></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <!-- ç‚¹å‡»ç©ºç™½å¤„è¿”å›æç¤º -->
        <div class="overlay-close-hint" id="rules-close-hint">ç‚¹å‡»ç©ºç™½å¤„è¿”å›</div>
    </div>
    
    <div class="overlay round-history-modal" id="history-overlay">
        <div class="modal-content" id="history-modal-content">
            <div class="modal-header">
                <h2 class="modal-title"><i class="fas fa-history"></i> å›åˆå†å²è®°å½•</h2>
            </div>
            <div class="history-table-container">
                <table class="history-table" id="history-table">
                    <thead>
                        <tr>
                            <th>å›åˆ</th>
                            <th>ç©å®¶</th>
                            <th>ç»„åˆè¯¦æƒ…</th>
                            <th>å¾—åˆ†</th>
                            <th>ç´¯è®¡</th>
                            <th>AI</th>
                            <th>ç»„åˆè¯¦æƒ…</th>
                            <th>å¾—åˆ†</th>
                            <th>ç´¯è®¡</th>
                        </tr>
                    </thead>
                    <tbody id="history-body"></tbody>
                </table>
            </div>
        </div>
        <!-- ç‚¹å‡»ç©ºç™½å¤„è¿”å›æç¤º -->
        <div class="overlay-close-hint" id="history-close-hint">ç‚¹å‡»ç©ºç™½å¤„è¿”å›</div>
    </div>

    <script>
        // ==================== è®¡åˆ†è§„åˆ™ ====================
        const SCORE_TABLE = {
            'same': { // å æ•°
                2: 10,  // 2å 
                3: 40,  // 3å 
                4: 80,  // 4å 
                5: 180, // 5å 
                6: 320  // 6å 
            },
            'sequence': { // è¿ç»­æ•°
                3: 20,  // 3è¿
                4: 60,  // 4è¿
                5: 100, // 5è¿
                6: 140  // 6è¿
            }
        };

        // æ¸¸æˆçŠ¶æ€å˜é‡
        const gameState = {
            playerScore: 0,
            aiScore: 0,
            targetScore: 500,
            currentPlayer: 'player',
            diceValues: [],
            selectedDice: [],
            currentSequence: [],
            roundScore: 0,
            gameActive: true,
            roundActive: false,
            diceCount: 6,
            canSelectNewSequence: true,
            currentCombination: [],
            currentRound: 1,
            playerRoundScore: 0,
            aiRoundScore: 0,
            roundCompleted: false,
            gameHistory: [],
            currentPlayerCombinationString: '',
            currentAICombinationString: '',
            soundEnabled: true,
            audioInitialized: false,
            rerollUsedThisTurn: false, // æ ‡è®°æœ¬å›åˆæ˜¯å¦å·²ä½¿ç”¨æŠ•æ·
            rerollButtonDarkened: false, // æ ‡è®°æŠ•æ·æŒ‰é’®æ˜¯å¦å·²å˜æš—
        };
        
        // DOMå…ƒç´ ç¼“å­˜
        const elements = {
            playerScore: document.querySelector('.player-score'),
            aiScore: document.querySelector('.ai-score'),
            playerRoundScore: document.getElementById('player-round-score-left'),
            aiRoundScore: document.getElementById('ai-round-score-left'),
            targetScore: document.getElementById('target-score'),
            roundNumber: document.getElementById('round-number'),
            turnIndicatorText: document.getElementById('turn-indicator-text'),
            diceContainer: document.getElementById('dice-container'),
            rerollBtn: document.getElementById('reroll-btn'),
            scoreBtn: document.getElementById('score-btn'),
            logContent: document.getElementById('log-content'),
            gameOverContainer: document.getElementById('game-over-container'),
            winnerText: document.getElementById('winner-text'),
            gameOverPlayerScore: document.getElementById('game-over-player-score'),
            gameOverAiScore: document.getElementById('game-over-ai-score'),
            gameOverPlayerAvg: document.getElementById('game-over-player-avg'),
            gameOverPlayerMax: document.getElementById('game-over-player-max'),
            gameOverAiAvg: document.getElementById('game-over-ai-avg'),
            gameOverAiMax: document.getElementById('game-over-ai-max'),
            gameOverRestartBtn: document.getElementById('game-over-restart-btn'),
            combinationTitle: document.getElementById('combination-title'),
            combinationDisplay: document.getElementById('combination-display'),
            totalScoreValue: document.getElementById('total-score-value'),
            totalScoreDisplay: document.getElementById('total-score-display'),
            playerCard: document.getElementById('player-card'),
            aiCard: document.getElementById('ai-card'),
            historyBody: document.getElementById('history-body'),
            soundControl: document.getElementById('sound-control'),
            rulesButton: document.getElementById('rules-button'),
            rulesOverlay: document.getElementById('rules-overlay'),
            historyButton: document.getElementById('history-button'),
            historyOverlay: document.getElementById('history-overlay'),
            roundInfoBar: document.getElementById('round-info-bar'),
            rulesModalContent: document.getElementById('rules-modal-content'),
            historyModalContent: document.getElementById('history-modal-content'),
            scoreControl: document.getElementById('score-control'),
            scoreTableOverlay: document.getElementById('score-table-overlay'),
            scoreTableModalContent: document.getElementById('score-table-modal-content'),
            playersInfo: document.querySelector('.players-info'),
            diceSection: document.querySelector('.dice-section'),
            gameLogCollapsible: document.getElementById('game-log-collapsible'),
            winnerElement: document.getElementById('game-over-winner'),
            gameOverRoundNumber: document.getElementById('game-over-round-number') // æ–°å¢ï¼šå›åˆæ•°æ˜¾ç¤º
        };
        
        // éŸ³æ•ˆç³»ç»Ÿ
        let audioContext;
        
        // åˆå§‹åŒ–éŸ³æ•ˆç³»ç»Ÿ
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                gameState.audioInitialized = true;
            }
        }
        
        // æ’­æ”¾éŸ³æ•ˆ
        function playSound(type) {
            if (!gameState.soundEnabled || !gameState.audioInitialized) return;
            
            try {
                if (audioContext.state === 'suspended') audioContext.resume();
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                const currentTime = audioContext.currentTime;
                
                const tones = {
                    diceRoll: {freq: 150, duration: 0.5},
                    diceSelect: {freq: 400, duration: 0.1},
                    buttonClick: {freq: 600, duration: 0.1},
                    win: {freq: [523.25, 659.25, 783.99, 1046.50], duration: 0.5},
                    lose: {freq: [261.63, 220.00, 196.00, 174.61], duration: 0.5}
                };
                
                const tone = tones[type];
                if (!tone) return;
                
                if (Array.isArray(tone.freq)) {
                    tone.freq.forEach((freq, index) => {
                        oscillator.frequency.setValueAtTime(freq, currentTime + index * 0.1);
                        gainNode.gain.setValueAtTime(0.3, currentTime + index * 0.1);
                    });
                    gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + tone.duration);
                    oscillator.start();
                    oscillator.stop(currentTime + tone.duration);
                } else {
                    oscillator.frequency.setValueAtTime(tone.freq, currentTime);
                    gainNode.gain.setValueAtTime(0.2, currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + tone.duration);
                    oscillator.start();
                    oscillator.stop(currentTime + tone.duration);
                }
            } catch (e) {
                console.log("éŸ³æ•ˆæ’­æ”¾å¤±è´¥:", e);
            }
        }
        
        // éŸ³æ•ˆæ§åˆ¶
        elements.soundControl.addEventListener('click', () => {
            gameState.soundEnabled = !gameState.soundEnabled;
            if (gameState.soundEnabled) {
                elements.soundControl.innerHTML = '<i class="fas fa-volume-up"></i>';
                elements.soundControl.classList.remove('muted');
                playSound('buttonClick');
            } else {
                elements.soundControl.innerHTML = '<i class="fas fa-volume-mute"></i>';
                elements.soundControl.classList.add('muted');
            }
        });
        
        // åˆ†æ•°è¡¨æŒ‰é’®äº‹ä»¶
        elements.scoreControl.addEventListener('click', () => {
            elements.scoreTableOverlay.style.display = 'flex';
            playSound('buttonClick');
        });
        
        // æŠ˜å /å±•å¼€åŠŸèƒ½
        function toggleCollapse(sectionId) {
            const content = document.getElementById(`${sectionId}-content`);
            const icon = document.getElementById(`${sectionId}-icon`);
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                icon.style.transform = 'rotate(0deg)';
            } else {
                content.classList.add('expanded');
                icon.style.transform = 'rotate(180deg)';
            }
        }
        
        // å¼¹çª—æ§åˆ¶
        elements.rulesButton.addEventListener('click', () => {
            elements.rulesOverlay.style.display = 'flex';
            playSound('buttonClick');
        });
        
        elements.historyButton.addEventListener('click', () => {
            elements.historyOverlay.style.display = 'flex';
            updateHistoryTable();
            playSound('buttonClick');
        });
        
        // ç‚¹å‡»é®ç½©å±‚å…³é—­å¼¹çª—
        elements.rulesOverlay.addEventListener('click', (e) => {
            if (e.target === elements.rulesOverlay) {
                elements.rulesOverlay.style.display = 'none';
                playSound('buttonClick');
            }
        });
        
        elements.historyOverlay.addEventListener('click', (e) => {
            if (e.target === elements.historyOverlay) {
                elements.historyOverlay.style.display = 'none';
                playSound('buttonClick');
            }
        });
        
        // æ–°å¢åˆ†æ•°è¡¨å¼¹çª—å…³é—­äº‹ä»¶
        elements.scoreTableOverlay.addEventListener('click', (e) => {
            if (e.target === elements.scoreTableOverlay) {
                elements.scoreTableOverlay.style.display = 'none';
                playSound('buttonClick');
            }
        });
        
        // é˜»æ­¢å¼¹çª—å†…å®¹ç‚¹å‡»äº‹ä»¶å†’æ³¡
        elements.rulesModalContent.addEventListener('click', (e) => e.stopPropagation());
        elements.historyModalContent.addEventListener('click', (e) => e.stopPropagation());
        elements.scoreTableModalContent.addEventListener('click', (e) => e.stopPropagation());
        
        // åˆå§‹åŒ–æŠ˜å çŠ¶æ€
        function initCollapsible() {
            document.getElementById('game-log-content').classList.add('expanded');
            document.getElementById('game-log-icon').style.transform = 'rotate(180deg)';
        }
        
        // åˆ›å»ºéª°å­ç‚¹æ•°æ˜¾ç¤º
        function createDicePoints(value) {
            if (value === '?') return '<div class="dice-question">?</div>';
            
            const numValue = parseInt(value);
            let dotsHtml = '';
            for (let i = 0; i < numValue; i++) dotsHtml += '<div class="dot"></div>';
            for (let i = numValue; i < 6; i++) dotsHtml += '<div class="dot" style="opacity: 0;"></div>';
            
            return `<div class="dice-points dice-${numValue}">${dotsHtml}</div>`;
        }
        
        // æ›´æ–°å›åˆä¿¡æ¯æ æ ·å¼
        function updateRoundInfoBar() {
            if (gameState.currentPlayer === 'player') {
                elements.roundInfoBar.className = 'round-info-bar player-turn-round';
                elements.turnIndicatorText.innerHTML = '<i class="fas fa-user"></i> ç©å®¶å›åˆ';
            } else {
                elements.roundInfoBar.className = 'round-info-bar ai-turn-round';
                elements.turnIndicatorText.innerHTML = '<i class="fas fa-robot"></i> AIå›åˆ';
            }
            elements.roundNumber.textContent = gameState.currentRound;
        }
        
        // æ›´æ–°å›åˆé«˜äº®æ˜¾ç¤º
        function updateTurnHighlight() {
            if (gameState.currentPlayer === 'player') {
                elements.playerCard.classList.add('active-turn');
                elements.aiCard.classList.remove('active-turn');
            } else {
                elements.aiCard.classList.add('active-turn');
                elements.playerCard.classList.remove('active-turn');
            }
        }
        
        // æ›´æ–°æŠ•æ·æŒ‰é’®çŠ¶æ€ - ä½¿ç”¨å˜æš—æ•ˆæœ
        function updateRerollButton() {
            // ç§»é™¤ä¹‹å‰çš„å˜æš—æ•ˆæœ
            elements.rerollBtn.classList.remove('darkened');
            
            if (gameState.rerollUsedThisTurn) {
                // å¦‚æœæœ¬å›åˆå·²ä½¿ç”¨æŠ•æ·ï¼Œåˆ™ç¦ç”¨æŒ‰é’®å¹¶æ·»åŠ å˜æš—æ•ˆæœ
                elements.rerollBtn.disabled = true;
                elements.rerollBtn.classList.add('darkened');
                gameState.rerollButtonDarkened = true;
            } else if (gameState.currentPlayer === 'player' && gameState.currentSequence.length >= 3) {
                // ç©å®¶å›åˆï¼Œé€‰æ‹©äº†3ä¸ªæˆ–ä»¥ä¸Šéª°å­ï¼ŒæŒ‰é’®å¯ç”¨
                elements.rerollBtn.disabled = false;
                gameState.rerollButtonDarkened = false;
            } else {
                // å…¶ä»–æƒ…å†µç¦ç”¨æŒ‰é’®ä½†ä¸å˜æš—
                elements.rerollBtn.disabled = true;
                gameState.rerollButtonDarkened = false;
            }
        }
        
        // æ›´æ–°AIå›åˆçš„æŠ•æ·æŒ‰é’®çŠ¶æ€
        function updateAIRerollButton() {
            // ç§»é™¤ä¹‹å‰çš„å˜æš—æ•ˆæœ
            elements.rerollBtn.classList.remove('darkened');
            
            if (gameState.rerollUsedThisTurn) {
                // å¦‚æœAIæœ¬å›åˆå·²ä½¿ç”¨æŠ•æ·ï¼Œåˆ™ç¦ç”¨æŒ‰é’®å¹¶æ·»åŠ å˜æš—æ•ˆæœ
                elements.rerollBtn.disabled = true;
                elements.rerollBtn.classList.add('darkened');
                gameState.rerollButtonDarkened = true;
            } else {
                // AIå›åˆï¼ŒæŒ‰é’®å§‹ç»ˆç¦ç”¨
                elements.rerollBtn.disabled = true;
                gameState.rerollButtonDarkened = false;
            }
        }
        
        // é‡ç½®æŠ•æ·æŒ‰é’®çŠ¶æ€ï¼ˆæ–°å›åˆå¼€å§‹ï¼‰
        function resetRerollButton() {
            gameState.rerollUsedThisTurn = false;
            gameState.rerollButtonDarkened = false;
            elements.rerollBtn.classList.remove('darkened');
            
            if (gameState.currentPlayer === 'player' && gameState.currentSequence.length >= 3) {
                elements.rerollBtn.disabled = false;
            } else {
                elements.rerollBtn.disabled = true;
            }
        }
        
        // æ›´æ–°è®¡åˆ†æŒ‰é’®çŠ¶æ€
        function updateScoreButton() {
            if (gameState.currentCombination.length > 0) {
                elements.scoreBtn.disabled = false;
            } else {
                elements.scoreBtn.disabled = true;
            }
        }
        
        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            Object.assign(gameState, {
                playerScore: 0,
                aiScore: 0,
                targetScore: 500,
                currentPlayer: 'player',
                diceValues: [],
                selectedDice: [],
                currentSequence: [],
                roundScore: 0,
                gameActive: true,
                roundActive: false,
                diceCount: 6,
                canSelectNewSequence: true,
                currentCombination: [],
                currentRound: 1,
                playerRoundScore: 0,
                aiRoundScore: 0,
                roundCompleted: false,
                gameHistory: [],
                currentPlayerCombinationString: '',
                currentAICombinationString: '',
                soundEnabled: gameState.soundEnabled,
                audioInitialized: gameState.audioInitialized,
                rerollUsedThisTurn: false,
                rerollButtonDarkened: false
            });
            
            updateScores();
            updateRoundScoreDisplay();
            updateRoundInfoBar();
            updateTurnHighlight();
            createDiceElements();
            updateCombinationDisplay([]);
            
            // é‡ç½®æŒ‰é’®çŠ¶æ€
            resetRerollButton();
            updateScoreButton();
            
            // éšè—æ¸¸æˆç»“æŸå®¹å™¨ï¼Œæ˜¾ç¤ºæ¸¸æˆåŒºåŸŸ
            elements.gameOverContainer.style.display = 'none';
            elements.playersInfo.style.display = 'flex';
            elements.diceSection.style.display = 'block';
            elements.gameLogCollapsible.style.display = 'block';
            
            elements.logContent.innerHTML = '';
            addLogEntry('ç³»ç»Ÿ', `æ¸¸æˆå¼€å§‹ï¼ç¬¬${gameState.currentRound}å›åˆï¼Œç©å®¶å…ˆæ‰‹ã€‚`, 'system');
            
            elements.rulesOverlay.style.display = 'none';
            elements.historyOverlay.style.display = 'none';
            elements.scoreTableOverlay.style.display = 'none';
            
            initCollapsible();
            if (!gameState.audioInitialized) initAudio();
            setTimeout(() => initialRollDice(), 1000);
        }
        
        // åˆå§‹æŠ•æ·éª°å­
        function initialRollDice() {
            gameState.diceValues = [];
            for (let i = 0; i < gameState.diceCount; i++) {
                gameState.diceValues.push(Math.floor(Math.random() * 6) + 1);
            }
            
            animateDiceRoll();
            playSound('diceRoll');
            
            setTimeout(() => {
                createDiceElements();
                const diceValuesText = gameState.diceValues.join(', ');
                addLogEntry(gameState.currentPlayer === 'player' ? 'ç©å®¶' : 'AI', `æŠ•æ·éª°å­: ${diceValuesText}`, gameState.currentPlayer);
                
                updateButtonState();
            }, 500);
        }
        
        // åˆ›å»ºéª°å­å…ƒç´ 
        function createDiceElements() {
            elements.diceContainer.innerHTML = '';
            
            for (let i = 0; i < gameState.diceCount; i++) {
                const diceWrapper = document.createElement('div');
                diceWrapper.className = 'dice-wrapper';
                
                const dice = document.createElement('div');
                dice.className = 'dice';
                dice.dataset.index = i;
                dice.dataset.value = gameState.diceValues[i] || '?';
                dice.innerHTML = createDicePoints(gameState.diceValues[i] || '?');
                
                if (gameState.diceValues[i]) {
                    dice.classList.remove('used', 'locked', 'selected', 'ai-selected');
                    if (gameState.selectedDice.includes(i)) dice.classList.add('used');
                    if (gameState.currentSequence.includes(i)) {
                        dice.classList.add(gameState.currentPlayer === 'player' ? 'selected' : 'ai-selected');
                    }
                }
                
                const diceLabel = document.createElement('div');
                diceLabel.className = 'dice-label';
                diceLabel.textContent = gameState.diceValues[i] || '?';
                
                diceWrapper.appendChild(dice);
                diceWrapper.appendChild(diceLabel);
                
                if (gameState.currentPlayer === 'player') {
                    dice.addEventListener('click', () => selectDice(i));
                    dice.style.cursor = 'pointer';
                } else {
                    dice.style.cursor = 'default';
                }
                elements.diceContainer.appendChild(diceWrapper);
            }
        }
        
        // æ›´æ–°éª°å­æ˜¾ç¤º
        function updateDiceDisplay() {
            document.querySelectorAll('.dice-wrapper').forEach((wrapper, index) => {
                const dice = wrapper.querySelector('.dice');
                const diceLabel = wrapper.querySelector('.dice-label');
                dice.innerHTML = createDicePoints(gameState.diceValues[index] || '?');
                dice.dataset.value = gameState.diceValues[index] || '?';
                diceLabel.textContent = gameState.diceValues[index] || '?';
                dice.classList.remove('selected', 'ai-selected', 'used', 'locked');
                if (gameState.selectedDice.includes(index)) dice.classList.add('used');
                else if (gameState.currentSequence.includes(index)) {
                    dice.classList.add(gameState.currentPlayer === 'player' ? 'selected' : 'ai-selected');
                }
            });
        }
        
        // æŠ•æ·éª°å­åŠ¨ç”»æ•ˆæœ
        function animateDiceRoll() {
            document.querySelectorAll('.dice').forEach((dice, index) => {
                if (!gameState.selectedDice.includes(index)) {
                    dice.classList.add('shaking');
                    setTimeout(() => dice.classList.remove('shaking'), 500);
                }
            });
        }
        
        // éª°å­è†¨èƒ€åŠ¨ç”»æ•ˆæœ
        function animateDiceBounce(indices) {
            indices.forEach(index => {
                const diceElement = document.querySelector(`.dice[data-index="${index}"]`);
                if (diceElement) {
                    diceElement.classList.add('bounce');
                    setTimeout(() => diceElement.classList.remove('bounce'), 600);
                }
            });
        }
        
        // æŒ‰é’®å›å¼¹åŠ¨ç”»
        function animateButtonBounce(button) {
            button.classList.add('bounce');
            setTimeout(() => {
                button.classList.remove('bounce');
            }, 600);
        }
        
        // æ ¹æ®é€‰æ‹©é¡ºåºåˆ†æç»„åˆ
        function analyzeAllCombinationsByOrder() {
            if (gameState.currentSequence.length === 0) return [];
            
            const orderedValues = gameState.currentSequence.map(i => gameState.diceValues[i]);
            const groups = [];
            let currentGroup = [];
            
            for (let i = 0; i < orderedValues.length; i++) {
                if (currentGroup.length === 0) {
                    currentGroup.push({index: gameState.currentSequence[i], value: orderedValues[i]});
                } else {
                    const lastValue = currentGroup[currentGroup.length - 1].value;
                    const currentValue = orderedValues[i];
                    const isConsecutive = currentValue === lastValue + 1;
                    const isSame = currentValue === lastValue;
                    
                    if (currentGroup.length === 1) {
                        if (isConsecutive || isSame) {
                            currentGroup.push({index: gameState.currentSequence[i], value: currentValue});
                        } else {
                            groups.push([...currentGroup]);
                            currentGroup = [{index: gameState.currentSequence[i], value: currentValue}];
                        }
                    } else {
                        const firstValue = currentGroup[0].value;
                        const secondValue = currentGroup[1].value;
                        const isSequenceGroup = secondValue === firstValue + 1;
                        const isSameGroup = secondValue === firstValue;
                        
                        if ((isSequenceGroup && isConsecutive) || (isSameGroup && isSame)) {
                            currentGroup.push({index: gameState.currentSequence[i], value: currentValue});
                        } else {
                            groups.push([...currentGroup]);
                            currentGroup = [{index: gameState.currentSequence[i], value: currentValue}];
                        }
                    }
                }
            }
            
            if (currentGroup.length > 0) groups.push([...currentGroup]);
            
            const allCombinations = [];
            
            // å°è¯•æ‰€æœ‰å¯èƒ½çš„ç»„åˆåˆ†å‰²æ–¹å¼
            for (let i = 0; i < groups.length; i++) {
                for (let j = i; j < groups.length; j++) {
                    const combinedGroups = groups.slice(i, j + 1);
                    const combination = [];
                    let isValid = true;
                    
                    for (const group of combinedGroups) {
                        if (group.length < 2) { isValid = false; break; }
                        
                        const values = group.map(g => g.value);
                        const firstValue = values[0];
                        const secondValue = values[1];
                        
                        if (secondValue === firstValue + 1) {
                            let isConsecutive = true;
                            for (let k = 1; k < values.length; k++) {
                                if (values[k] !== values[k-1] + 1) { isConsecutive = false; break; }
                            }
                            
                            if (isConsecutive && values.length >= 3) {
                                const score = SCORE_TABLE.sequence[values.length] || 0;
                                combination.push({
                                    type: 'sequence',
                                    values: values,
                                    score: score,
                                    indices: group.map(g => g.index)
                                });
                            } else { isValid = false; break; }
                        } else if (secondValue === firstValue) {
                            let allSame = true;
                            for (let k = 1; k < values.length; k++) {
                                if (values[k] !== firstValue) { allSame = false; break; }
                            }
                            
                            if (allSame && values.length >= 2) {
                                const score = SCORE_TABLE.same[values.length] || 0;
                                combination.push({
                                    type: 'same',
                                    value: firstValue,
                                    count: values.length,
                                    score: score,
                                    indices: group.map(g => g.index)
                                });
                            } else { isValid = false; break; }
                        } else { isValid = false; break; }
                    }
                    
                    if (isValid && combination.length > 0) {
                        const allIndices = combination.flatMap(item => item.indices);
                        if (allIndices.length === gameState.currentSequence.length) {
                            const uniqueIndices = [...new Set(allIndices)];
                            if (uniqueIndices.length === allIndices.length) {
                                allCombinations.push({
                                    combinations: combination,
                                    totalScore: combination.reduce((sum, item) => sum + item.score, 0),
                                    totalDiceUsed: allIndices.length
                                });
                            }
                        }
                    }
                }
            }
            
            allCombinations.sort((a, b) => {
                if (b.totalScore !== a.totalScore) return b.totalScore - a.totalScore;
                return b.totalDiceUsed - a.totalDiceUsed;
            });
            
            return allCombinations.length > 0 ? allCombinations[0].combinations : [];
        }
        
        // ç”Ÿæˆç»„åˆå­—ç¬¦ä¸²
        function generateCombinationString(combination) {
            if (!combination || combination.length === 0) return '';
            return combination.map(item => 
                item.type === 'sequence' ? item.values.join(',') : Array(item.count).fill(item.value).join(',')
            ).join('+');
        }
        
        // é€‰æ‹©éª°å­
        function selectDice(index) {
            if (!gameState.gameActive || gameState.currentPlayer !== 'player' || 
                gameState.selectedDice.includes(index)) return;
            
            playSound('diceSelect');
            
            if (gameState.currentSequence.includes(index)) {
                const position = gameState.currentSequence.indexOf(index);
                gameState.currentSequence.splice(position, 1);
                updateDiceDisplay();
                gameState.currentCombination = analyzeAllCombinationsByOrder();
                updateCombinationDisplay(gameState.currentCombination);
                updateButtonState();
                return;
            }
            
            gameState.currentSequence.push(index);
            updateDiceDisplay();
            gameState.currentCombination = analyzeAllCombinationsByOrder();
            updateCombinationDisplay(gameState.currentCombination);
            updateButtonState();
        }
        
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        function updateButtonState() {
            // è®¡åˆ†æŒ‰é’®ï¼šæœ‰æœ‰æ•ˆç»„åˆæ—¶å¯ç”¨
            updateScoreButton();
            
            // æŠ•æ·æŒ‰é’®çŠ¶æ€
            updateRerollButton();
        }
        
        // æ›´æ–°ç»„åˆæ˜¾ç¤º
        function updateCombinationDisplay(combination, isAI = false) {
            elements.combinationDisplay.innerHTML = '';
            
            if (combination.length === 0) {
                if (gameState.currentPlayer === 'player') {
                    elements.combinationTitle.innerHTML = '<i class="fas fa-list-ol"></i> å½“å‰ç»„åˆåˆ†æ';
                } else {
                    elements.combinationTitle.innerHTML = '<i class="fas fa-robot"></i> AIç»„åˆåˆ†æ';
                }
                elements.totalScoreValue.textContent = '0';
                elements.totalScoreDisplay.style.display = 'none';
                return;
            }
            
            let totalScore = 0;
            combination.forEach(item => {
                const combinationItem = document.createElement('div');
                combinationItem.className = `combination-item ${isAI ? 'ai-combination-item' : ''}`;
                
                const typeSpan = document.createElement('span');
                typeSpan.className = `combination-type ${isAI ? 'ai-combination-type' : ''}`;
                typeSpan.textContent = item.type === 'sequence' ? 'è¿ç»­æ•°' : 'å æ•°';
                
                const valuesSpan = document.createElement('span');
                valuesSpan.className = 'combination-values';
                
                if (item.type === 'sequence') {
                    item.values.forEach((value, idx) => {
                        const diceSpan = document.createElement('span');
                        diceSpan.className = `combination-dice ${isAI ? 'ai-combination-dice' : ''}`;
                        diceSpan.textContent = value;
                        valuesSpan.appendChild(diceSpan);
                        if (idx < item.values.length - 1) valuesSpan.appendChild(document.createTextNode(', '));
                    });
                } else {
                    for (let i = 0; i < item.count; i++) {
                        const diceSpan = document.createElement('span');
                        diceSpan.className = `combination-dice ${isAI ? 'ai-combination-dice' : ''}`;
                        diceSpan.textContent = item.value;
                        valuesSpan.appendChild(diceSpan);
                        if (i < item.count - 1) valuesSpan.appendChild(document.createTextNode(', '));
                    }
                }
                
                const scoreSpan = document.createElement('span');
                scoreSpan.className = 'combination-score';
                scoreSpan.textContent = `${item.score}åˆ†`;
                
                combinationItem.appendChild(typeSpan);
                combinationItem.appendChild(valuesSpan);
                combinationItem.appendChild(scoreSpan);
                elements.combinationDisplay.appendChild(combinationItem);
                totalScore += item.score;
            });
            
            elements.totalScoreValue.textContent = `${totalScore}åˆ†`;
            elements.totalScoreDisplay.style.display = 'flex';
            elements.combinationTitle.innerHTML = isAI ? '<i class="fas fa-robot"></i> AIç»„åˆåˆ†æ' : '<i class="fas fa-list-ol"></i> å½“å‰ç»„åˆåˆ†æ';
        }
        
        // æ·»åŠ æ—¥å¿—æ¡ç›®
        function addLogEntry(who, message, type) {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}-log`;
            const time = new Date().toLocaleTimeString('zh-CN', {hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'});
            logEntry.innerHTML = `<strong>[${time}] ${who}:</strong> ${message}`;
            
            // æ·»åŠ åˆ°æ¸¸æˆæ—¥å¿—
            if (elements.logContent.firstChild) elements.logContent.insertBefore(logEntry, elements.logContent.firstChild);
            else elements.logContent.appendChild(logEntry);
            
            document.getElementById('game-log-content').classList.add('expanded');
            document.getElementById('game-log-icon').style.transform = 'rotate(180deg)';
        }
        
        // æ›´æ–°åˆ†æ•°æ˜¾ç¤º
        function updateScores() {
            elements.playerScore.textContent = gameState.playerScore;
            elements.aiScore.textContent = gameState.aiScore;
            elements.targetScore.textContent = gameState.targetScore;
        }
        
        // æ›´æ–°å›åˆåˆ†æ•°æ˜¾ç¤º
        function updateRoundScoreDisplay() {
            if (gameState.currentPlayer === 'player') {
                elements.playerRoundScore.textContent = `æœ¬å›åˆ: ${gameState.roundScore}`;
                elements.aiRoundScore.textContent = `æœ¬å›åˆ: ${gameState.currentRound > 1 ? gameState.aiRoundScore : 0}`;
            } else {
                elements.playerRoundScore.textContent = `æœ¬å›åˆ: ${gameState.playerRoundScore}`;
                elements.aiRoundScore.textContent = `æœ¬å›åˆ: ${gameState.roundScore}`;
            }
        }
        
        // æ›´æ–°å†å²è¡¨æ ¼
        function updateHistoryTable() {
            elements.historyBody.innerHTML = '';
            gameState.gameHistory.forEach(round => {
                const row = document.createElement('tr');
                
                const createCell = (text, className) => {
                    const cell = document.createElement('td');
                    cell.textContent = text;
                    if (className) cell.className = className;
                    return cell;
                };
                
                row.appendChild(createCell(round.round));
                row.appendChild(createCell('ç©å®¶', 'player-round'));
                row.appendChild(createCell(round.playerCombination, 'round-combination player-round'));
                row.appendChild(createCell(round.playerScore, 'player-round'));
                row.appendChild(createCell(round.playerCumulativeScore, 'player-round'));
                row.appendChild(createCell('AI', 'ai-round'));
                row.appendChild(createCell(round.aiCombination, 'round-combination ai-round'));
                row.appendChild(createCell(round.aiScore, 'ai-round'));
                row.appendChild(createCell(round.aiCumulativeScore, 'ai-round'));
                
                elements.historyBody.appendChild(row);
            });
        }
        
        // æ›´æ–°æ¸¸æˆç»“æŸç•Œé¢ç»Ÿè®¡ä¿¡æ¯
        function updateGameOverStats() {
            elements.gameOverPlayerScore.textContent = gameState.playerScore;
            elements.gameOverAiScore.textContent = gameState.aiScore;
            
            // æ›´æ–°å›åˆæ•°æ˜¾ç¤º
            const totalRounds = gameState.gameHistory.length;
            elements.gameOverRoundNumber.textContent = totalRounds;
            
            if (totalRounds > 0) {
                const playerTotalScore = gameState.gameHistory.reduce((sum, round) => sum + round.playerScore, 0);
                elements.gameOverPlayerAvg.textContent = Math.round(playerTotalScore / totalRounds);
                elements.gameOverPlayerMax.textContent = Math.max(...gameState.gameHistory.map(round => round.playerScore));
                
                const aiTotalScore = gameState.gameHistory.reduce((sum, round) => sum + round.aiScore, 0);
                elements.gameOverAiAvg.textContent = Math.round(aiTotalScore / totalRounds);
                elements.gameOverAiMax.textContent = Math.max(...gameState.gameHistory.map(round => round.aiScore));
            } else {
                elements.gameOverPlayerAvg.textContent = 0;
                elements.gameOverPlayerMax.textContent = 0;
                elements.gameOverAiAvg.textContent = 0;
                elements.gameOverAiMax.textContent = 0;
            }
        }
        
        // ==================== æŠ•æ·æŒ‰é’®åŠŸèƒ½ï¼ˆå›å¼¹åå˜æš—ï¼‰ ====================
        function rerollSelectedDice() {
            if (!gameState.gameActive || gameState.currentPlayer !== 'player') return;
            if (gameState.currentSequence.length < 3) return;
            if (gameState.rerollUsedThisTurn) return;
            
            playSound('buttonClick');
            
            // æ·»åŠ æŒ‰é’®å›å¼¹åŠ¨ç”»
            animateButtonBounce(elements.rerollBtn);
            
            // è®°å½•ä½¿ç”¨æŠ•æ·
            gameState.rerollUsedThisTurn = true;
            
            // å»¶è¿Ÿåæ›´æ–°æŒ‰é’®çŠ¶æ€ï¼ˆå›å¼¹åå˜æš—ï¼‰
            setTimeout(() => {
                updateRerollButton();
            }, 400);
            
            // æ˜¾ç¤ºé—®å·
            gameState.currentSequence.forEach(index => {
                gameState.diceValues[index] = '?';
            });
            updateDiceDisplay();
            
            addLogEntry('ç©å®¶', `é‡æŠ• ${gameState.currentSequence.length} ä¸ªéª°å­`, 'player');
            
            // å»¶è¿Ÿåæ˜¾ç¤ºåŠ¨ç”»å’Œæ–°ç‚¹æ•°
            setTimeout(() => {
                // æŠ–åŠ¨åŠ¨ç”»
                gameState.currentSequence.forEach(index => {
                    const diceElement = document.querySelector(`.dice[data-index="${index}"]`);
                    if (diceElement) {
                        diceElement.classList.add('shaking');
                    }
                });
                
                playSound('diceRoll');
                
                // ç”Ÿæˆæ–°ç‚¹æ•°
                setTimeout(() => {
                    gameState.currentSequence.forEach(index => {
                        gameState.diceValues[index] = Math.floor(Math.random() * 6) + 1;
                    });
                    
                    // åœæ­¢åŠ¨ç”»å¹¶æ›´æ–°æ˜¾ç¤º
                    gameState.currentSequence.forEach(index => {
                        const diceElement = document.querySelector(`.dice[data-index="${index}"]`);
                        if (diceElement) {
                            diceElement.classList.remove('shaking');
                        }
                    });
                    
                    // æ¸…é™¤é€‰ä¸­çŠ¶æ€ï¼Œä»¥ä¾¿é‡æ–°é€‰æ‹©
                    gameState.currentSequence = [];
                    gameState.currentCombination = [];
                    
                    updateDiceDisplay();
                    updateCombinationDisplay([]);
                    
                    const diceValuesText = gameState.diceValues.join(', ');
                    addLogEntry('ç³»ç»Ÿ', `é‡æŠ•ç»“æœ: ${diceValuesText}`, 'system');
                    
                    // æ›´æ–°æŒ‰é’®çŠ¶æ€
                    updateButtonState();
                }, 500);
            }, 300);
        }
        
        // ==================== è®¡åˆ†æŒ‰é’®åŠŸèƒ½ ====================
        function scoreAndEndTurn() {
            if (!gameState.gameActive) return;
            if (gameState.currentCombination.length === 0) return;
            
            playSound('buttonClick');
            
            // æ·»åŠ æŒ‰é’®å›å¼¹åŠ¨ç”»
            animateButtonBounce(elements.scoreBtn);
            
            const totalScore = gameState.currentCombination.reduce((sum, item) => sum + item.score, 0);
            const allIndices = gameState.currentCombination.flatMap(item => item.indices);
            const descriptionParts = gameState.currentCombination.map(item => 
                item.type === 'sequence' ? `${item.values.length}è¿(${item.values.join(',')})` : `${item.count}å (${item.value})`
            );
            
            const uniqueIndices = [...new Set(allIndices)];
            if (uniqueIndices.length !== allIndices.length) return;
            
            // æ·»åŠ éª°å­è†¨èƒ€åŠ¨ç”»
            animateDiceBounce(allIndices);
            
            gameState.selectedDice.push(...allIndices);
            gameState.roundScore += totalScore;
            
            if (gameState.currentPlayer === 'player') {
                gameState.playerRoundScore = gameState.roundScore;
                const currentCombinationString = generateCombinationString(gameState.currentCombination);
                if (gameState.currentPlayerCombinationString) {
                    gameState.currentPlayerCombinationString += '+' + currentCombinationString;
                } else gameState.currentPlayerCombinationString = currentCombinationString;
            } else {
                gameState.aiRoundScore = gameState.roundScore;
                const currentCombinationString = generateCombinationString(gameState.currentCombination);
                if (gameState.currentAICombinationString) {
                    gameState.currentAICombinationString += '+' + currentCombinationString;
                } else gameState.currentAICombinationString = currentCombinationString;
            }
            
            // ç®€åŒ–æ—¥å¿—
            const action = gameState.currentPlayer === 'player' ? 'ç©å®¶' : 'AI';
            const comboDesc = descriptionParts.join(' + ');
            addLogEntry(action, `é€‰æ‹©ç»„åˆ: ${comboDesc}ï¼Œå¾—åˆ†${totalScore}åˆ†ï¼Œç»“æŸæœ¬å›åˆ`, gameState.currentPlayer);
            
            gameState.currentSequence = [];
            gameState.currentCombination = [];
            
            // å»¶è¿Ÿåç»“æŸå›åˆ
            setTimeout(() => endRound(), 1000);
        }
        
        // ç»“æŸæœ¬å›åˆå¹¶è®¡åˆ†
        function endRound() {
            if (!gameState.gameActive) return;
            
            if (gameState.currentPlayer === 'player') {
                gameState.playerScore += gameState.roundScore;
                addLogEntry('ç©å®¶', `è·å¾—${gameState.roundScore}åˆ†ï¼Œæ€»åˆ†: ${gameState.playerScore}`, 'player');
                if (gameState.playerScore >= gameState.targetScore) addLogEntry('ç³»ç»Ÿ', `ç©å®¶è¾¾åˆ°ç›®æ ‡åˆ†æ•° ${gameState.targetScore}ï¼`, 'system');
            } else {
                gameState.aiScore += gameState.roundScore;
                addLogEntry('AI', `è·å¾—${gameState.roundScore}åˆ†ï¼Œæ€»åˆ†: ${gameState.aiScore}`, 'ai');
                if (gameState.aiScore >= gameState.targetScore) addLogEntry('ç³»ç»Ÿ', `AIè¾¾åˆ°ç›®æ ‡åˆ†æ•° ${gameState.targetScore}ï¼`, 'system');
            }
            
            updateScores();
            checkRoundEnd();
            if (!gameState.gameActive) return;
            
            if (gameState.currentPlayer === 'ai') {
                gameState.roundCompleted = true;
                updateRoundInfoBar();
                gameState.gameHistory.push({
                    round: gameState.currentRound,
                    playerScore: gameState.playerRoundScore,
                    playerCumulativeScore: gameState.playerScore,
                    aiScore: gameState.aiRoundScore,
                    aiCumulativeScore: gameState.aiScore,
                    playerCombination: gameState.currentPlayerCombinationString || 'æ— æœ‰æ•ˆç»„åˆ',
                    aiCombination: gameState.currentAICombinationString || 'æ— æœ‰æ•ˆç»„åˆ'
                });
                
                addLogEntry('ç³»ç»Ÿ', `ç¬¬${gameState.currentRound}å›åˆç»“æŸï¼ç©å®¶: ${gameState.playerRoundScore}åˆ†ï¼ŒAI: ${gameState.aiRoundScore}åˆ†`, 'system');
                
                setTimeout(() => {
                    gameState.roundScore = 0; gameState.roundActive = false; gameState.canSelectNewSequence = true;
                    gameState.currentSequence = []; gameState.currentCombination = []; gameState.selectedDice = [];
                    gameState.currentPlayerCombinationString = ''; gameState.currentAICombinationString = '';
                    gameState.currentRound++; gameState.playerRoundScore = 0; gameState.aiRoundScore = 0; gameState.roundCompleted = false;
                    gameState.currentPlayer = 'player';
                    // é‡ç½®æŠ•æ·æŒ‰é’®çŠ¶æ€
                    resetRerollButton();
                    updateScoreButton(); // æ›´æ–°è®¡åˆ†æŒ‰é’®çŠ¶æ€
                    gameState.diceValues = new Array(gameState.diceCount).fill('?');
                    createDiceElements(); updateCombinationDisplay([]);
                    addLogEntry('ç³»ç»Ÿ', `ç¬¬${gameState.currentRound}å›åˆå¼€å§‹ï¼ç©å®¶å…ˆæ‰‹ã€‚`, 'system');
                    setTimeout(() => initialRollDice(), 1000);
                }, 800);
            } else {
                gameState.roundScore = 0; gameState.roundActive = false; gameState.canSelectNewSequence = true;
                gameState.currentSequence = []; gameState.currentCombination = []; gameState.selectedDice = [];
                gameState.currentPlayer = 'ai';
                // AIå›åˆå¼€å§‹æ—¶é‡ç½®æŠ•æ·æŒ‰é’®çŠ¶æ€
                resetRerollButton();
                updateScoreButton(); // æ›´æ–°è®¡åˆ†æŒ‰é’®çŠ¶æ€
                gameState.diceValues = new Array(gameState.diceCount).fill('?');
                createDiceElements(); updateCombinationDisplay([]);
                addLogEntry('ç³»ç»Ÿ', `è½®åˆ°AIå›åˆ`, 'system');
                setTimeout(() => aiTurn(), 1500);
            }
        }
        
        // æ£€æŸ¥å›åˆç»“æŸæ¡ä»¶
        function checkRoundEnd() {
            if (!gameState.gameActive) return;
            if (gameState.currentPlayer === 'ai') {
                if (gameState.playerScore >= gameState.targetScore || gameState.aiScore >= gameState.targetScore) {
                    gameState.gameActive = false;
                    gameState.gameHistory.push({
                        round: gameState.currentRound,
                        playerScore: gameState.playerRoundScore,
                        playerCumulativeScore: gameState.playerScore,
                        aiScore: gameState.aiRoundScore,
                        aiCumulativeScore: gameState.aiScore,
                        playerCombination: gameState.currentPlayerCombinationString || 'æ— æœ‰æ•ˆç»„åˆ',
                        aiCombination: gameState.currentAICombinationString || 'æ— æœ‰æ•ˆç»„åˆ'
                    });
                    
                    let winner;
                    if (gameState.playerScore > gameState.aiScore) winner = 'player';
                    else if (gameState.aiScore > gameState.playerScore) winner = 'ai';
                    else winner = 'tie';
                    endGame(winner);
                }
            }
        }
        
        // ==================== AIé€»è¾‘ ====================
        function aiTurn() {
            // åˆå§‹æŠ•æ·
            initialRollDice();
            
            // å»¶è¿ŸåAIå†³ç­–
            setTimeout(() => {
                aiDecision();
            }, 1500);
        }
        
        function aiDecision() {
            if (!gameState.gameActive || gameState.currentPlayer !== 'ai') return;
            
            // åˆ†æå½“å‰éª°å­
            const availableDice = [];
            for (let i = 0; i < gameState.diceCount; i++) {
                if (!gameState.selectedDice.includes(i)) {
                    availableDice.push({index: i, value: gameState.diceValues[i]});
                }
            }
            
            // åˆ†ææ‰€æœ‰å¯èƒ½çš„ç»„åˆ
            const allCombinations = findAllValidCombinationsForAI(availableDice);
            
            // è®¡ç®—å½“å‰æœ€å¤§ç»„åˆ
            let bestCombinationSet = null;
            if (allCombinations.length > 0) {
                bestCombinationSet = allCombinations[0];
            }
            
            // åˆ¤æ–­æ˜¯å¦æœ‰2å ã€3è¿ã€3å çš„ä¸­ç­‰ç»„åˆ
            let hasMediumCombo = false;
            if (bestCombinationSet) {
                for (const combination of bestCombinationSet.combinations) {
                    if ((combination.type === 'same' && combination.count === 2) || // 2å 
                        (combination.type === 'sequence' && combination.values.length === 3) || // 3è¿
                        (combination.type === 'same' && combination.count === 3)) { // 3å 
                        hasMediumCombo = true;
                        break;
                    }
                }
            }
            
            // åˆ¤æ–­æ˜¯å¦æœ‰4è¿åŠä»¥ä¸Šæˆ–4å åŠä»¥ä¸Šçš„å¤§åˆ†ç»„åˆ
            let hasBigCombo = false;
            if (bestCombinationSet) {
                for (const combination of bestCombinationSet.combinations) {
                    if ((combination.type === 'sequence' && combination.values.length >= 4) || 
                        (combination.type === 'same' && combination.count >= 4)) {
                        hasBigCombo = true;
                        break;
                    }
                }
            }
            
            // AIå†³ç­–é€»è¾‘
            let decision;
            
            // å¦‚æœæœ‰å¤§åˆ†ç»„åˆï¼Œç›´æ¥è®¡åˆ†
            if (hasBigCombo) {
                decision = { action: 'score', reason: 'æœ‰å¤§åˆ†ç»„åˆ(4+)ï¼Œç›´æ¥è®¡åˆ†' };
            }
            // å¦‚æœæœ‰ä¸­ç­‰ç»„åˆï¼ˆ2å ã€3è¿ã€3å ï¼‰å¹¶ä¸”è¿˜æ²¡ä½¿ç”¨è¿‡æŠ•æ·ï¼Œåˆ™100%æŠ•æ·
            else if (hasMediumCombo && !gameState.rerollUsedThisTurn) {
                decision = { action: 'reroll', reason: 'æœ‰ä¸­ç­‰ç»„åˆ(2å /3è¿/3å )ï¼Œå°è¯•é‡æŠ•æŒ‘æˆ˜å¤§åˆ†ç»„åˆ' };
            }
            // å…¶ä»–æƒ…å†µï¼ˆæ— æœ‰æ•ˆç»„åˆæˆ–åªæœ‰å°ç»„åˆï¼‰ï¼Œå¦‚æœè¿˜æ²¡ä½¿ç”¨è¿‡æŠ•æ·ï¼Œ100%æŠ•æ·
            else if (!gameState.rerollUsedThisTurn) {
                decision = { action: 'reroll', reason: 'æ— æœ‰æ•ˆç»„åˆæˆ–åªæœ‰å°ç»„åˆï¼Œå°è¯•é‡æŠ•' };
            }
            // å·²ç»ä½¿ç”¨è¿‡æŠ•æ·ï¼Œåªèƒ½è®¡åˆ†
            else {
                decision = { action: 'score', reason: bestCombinationSet ? 'é€‰æ‹©æœ€ä½³ç»„åˆè®¡åˆ†' : 'æ— æœ‰æ•ˆç»„åˆ' };
            }
            
            // åˆå¹¶å†³ç­–å’ŒåŠ¨ä½œåˆ°ä¸€æ¡æ—¥å¿—
            addLogEntry('AI', `${decision.reason}`, 'ai');
            
            // æ‰§è¡Œå†³ç­–
            if (decision.action === 'reroll') {
                // AIé€‰æ‹©éª°å­è¿›è¡Œé‡æŠ•
                aiSelectDiceForReroll(availableDice, bestCombinationSet);
            } else {
                // AIé€‰æ‹©æœ€ä½³ç»„åˆè®¡åˆ†
                if (bestCombinationSet) {
                    aiSelectBestCombination(bestCombinationSet);
                } else {
                    addLogEntry('AI', 'æ— æœ‰æ•ˆç»„åˆï¼Œç»“æŸå›åˆ', 'ai');
                    gameState.currentAICombinationString = 'æ— æœ‰æ•ˆç»„åˆ';
                    setTimeout(() => endRound(), 1000);
                }
            }
        }
        
        // ä¸ºAIæ‰¾å‡ºæ‰€æœ‰å¯èƒ½çš„ä¸é‡å ç»„åˆ
        function findAllValidCombinationsForAI(availableDice) {
            if (availableDice.length < 2) return [];
            
            const diceCount = availableDice.length;
            const diceValues = availableDice.map(d => d.value);
            const diceIndices = availableDice.map(d => d.index);
            
            // æ‰€æœ‰å¯èƒ½çš„ç»„åˆé›†åˆ
            const allCombinationSets = [];
            
            // é€’å½’æœç´¢å‡½æ•°
            function searchCombinations(currentSet, usedIndices, currentScore, startIndex) {
                // ä¿å­˜å½“å‰ç»„åˆé›†åˆ
                if (currentSet.length > 0) {
                    allCombinationSets.push({
                        combinations: [...currentSet],
                        totalScore: currentScore,
                        totalDiceUsed: usedIndices.size
                    });
                }
                
                // å¦‚æœå·²ç»ç”¨å®Œæ‰€æœ‰éª°å­ï¼Œåœæ­¢æœç´¢
                if (usedIndices.size === diceCount) return;
                
                // å°è¯•æ‰€æœ‰å¯èƒ½çš„ç»„åˆ
                for (let i = startIndex; i < diceCount; i++) {
                    // è·³è¿‡å·²ä½¿ç”¨çš„éª°å­
                    if (usedIndices.has(diceIndices[i])) continue;
                    
                    // 1. å°è¯•è¿ç»­æ•°ç»„åˆ
                    // æŸ¥æ‰¾ä»å½“å‰éª°å­å¼€å§‹çš„è¿ç»­æ•°
                    for (let len = 3; len <= Math.min(6, diceCount - usedIndices.size); len++) {
                        // å¯èƒ½çš„è¿ç»­æ•°å€¼
                        const startValue = diceValues[i];
                        const sequence = [];
                        for (let j = 0; j < len; j++) sequence.push(startValue + j);
                        
                        // æ£€æŸ¥æ˜¯å¦èƒ½ç”¨å‰©ä½™éª°å­ç»„æˆè¿™ä¸ªåºåˆ—
                        const neededIndices = new Set();
                        const neededValues = [...sequence];
                        let canFormSequence = true;
                        
                        // ä¸ºåºåˆ—ä¸­çš„æ¯ä¸ªå€¼æ‰¾ä¸€ä¸ªéª°å­
                        for (let j = 0; j < sequence.length; j++) {
                            const targetValue = sequence[j];
                            let found = false;
                            
                            for (let k = 0; k < diceCount; k++) {
                                if (!usedIndices.has(diceIndices[k]) && !neededIndices.has(diceIndices[k]) && 
                                    diceValues[k] === targetValue) {
                                    neededIndices.add(diceIndices[k]);
                                    found = true;
                                    break;
                                }
                            }
                            
                            if (!found) {
                                canFormSequence = false;
                                break;
                            }
                        }
                        
                        if (canFormSequence && neededIndices.size === sequence.length) {
                            const newUsedIndices = new Set([...usedIndices, ...neededIndices]);
                            const newSet = [...currentSet, {
                                type: 'sequence',
                                values: sequence,
                                score: SCORE_TABLE.sequence[sequence.length] || 0,
                                indices: Array.from(neededIndices)
                            }];
                            
                            searchCombinations(newSet, newUsedIndices, currentScore + (SCORE_TABLE.sequence[sequence.length] || 0), i + 1);
                        }
                    }
                    
                    // 2. å°è¯•å æ•°ç»„åˆ
                    // ç»Ÿè®¡å½“å‰å€¼åœ¨å‰©ä½™éª°å­ä¸­çš„æ•°é‡
                    const currentValue = diceValues[i];
                    let sameValueCount = 0;
                    const sameValueIndices = [];
                    
                    for (let j = 0; j < diceCount; j++) {
                        if (!usedIndices.has(diceIndices[j]) && diceValues[j] === currentValue) {
                            sameValueCount++;
                            sameValueIndices.push(diceIndices[j]);
                        }
                    }
                    
                    // å°è¯•æ‰€æœ‰å¯èƒ½çš„å æ•°å¤§å°ï¼ˆ2åˆ°æœ€å¤§æ•°é‡ï¼‰
                    for (let n = 2; n <= sameValueCount; n++) {
                        const selectedIndices = sameValueIndices.slice(0, n);
                        const newUsedIndices = new Set([...usedIndices, ...selectedIndices]);
                        const newSet = [...currentSet, {
                            type: 'same',
                            value: currentValue,
                            count: n,
                            score: SCORE_TABLE.same[n] || 0,
                            indices: selectedIndices
                        }];
                        
                        searchCombinations(newSet, newUsedIndices, currentScore + (SCORE_TABLE.same[n] || 0), i + 1);
                    }
                }
            }
            
            // å¼€å§‹æœç´¢
            searchCombinations([], new Set(), 0, 0);
            
            if (allCombinationSets.length === 0) return [];
            
            // æŒ‰æ€»åˆ†æ’åºï¼Œåˆ†æ•°ç›¸åŒçš„æŒ‰ä½¿ç”¨éª°å­æ•°å¤šçš„ä¼˜å…ˆ
            allCombinationSets.sort((a, b) => {
                if (b.totalScore !== a.totalScore) return b.totalScore - a.totalScore;
                return b.totalDiceUsed - a.totalDiceUsed;
            });
            
            return allCombinationSets;
        }
        
        function aiSelectDiceForReroll(availableDice, bestCombinationSet) {
            // AIé€‰æ‹©éª°å­è¿›è¡Œé‡æŠ•çš„ç­–ç•¥
            let diceToReroll = [];
            
            // å¦‚æœå·²æœ‰ç»„åˆï¼Œä¿ç•™ç»„åˆä¸­çš„éª°å­ï¼Œé‡æŠ•å…¶ä»–éª°å­
            if (bestCombinationSet && bestCombinationSet.combinations.length > 0) {
                const bestIndices = bestCombinationSet.combinations.flatMap(comb => comb.indices);
                
                // é‡æŠ•ä¸åœ¨æœ€ä½³ç»„åˆä¸­çš„éª°å­
                diceToReroll = availableDice
                    .map(d => d.index)
                    .filter(index => !bestIndices.includes(index));
                
                // å¦‚æœé‡æŠ•çš„éª°å­ä¸è¶³3ä¸ªï¼Œä»æœ€ä½³ç»„åˆä¸­ä¹Ÿé‡æŠ•ä¸€äº›
                if (diceToReroll.length < 3) {
                    const needed = 3 - diceToReroll.length;
                    if (needed > 0 && bestIndices.length > 0) {
                        // ä»æœ€ä½³ç»„åˆä¸­å–ä¸€äº›éª°å­é‡æŠ•ï¼ˆä¼˜å…ˆä¿ç•™å¤§åˆ†ç»„åˆï¼‰
                        const additional = bestIndices.slice(0, Math.min(needed, bestIndices.length));
                        diceToReroll = [...diceToReroll, ...additional];
                    }
                }
            } else {
                // æ²¡æœ‰å¥½ç»„åˆï¼Œéšæœºé€‰æ‹©3-4ä¸ªéª°å­é‡æŠ•
                const count = Math.min(availableDice.length, Math.floor(Math.random() * 2) + 3);
                const shuffled = [...availableDice].sort(() => Math.random() - 0.5);
                diceToReroll = shuffled.slice(0, count).map(d => d.index);
            }
            
            // è®¾ç½®AIé€‰æ‹©çš„éª°å­
            gameState.currentSequence = diceToReroll;
            updateDiceDisplay();
            
            // è®°å½•AIä½¿ç”¨æŠ•æ·
            gameState.rerollUsedThisTurn = true;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€ï¼Œä½¿æŠ•æ·æŒ‰é’®å˜æš—
            updateAIRerollButton();
            
            // æ‰§è¡Œé‡æŠ•
            setTimeout(() => {
                aiExecuteReroll();
            }, 1000);
        }
        
        function aiExecuteReroll() {
            // æ˜¾ç¤ºé—®å·
            gameState.currentSequence.forEach(index => {
                gameState.diceValues[index] = '?';
            });
            updateDiceDisplay();
            
            // å»¶è¿Ÿåæ˜¾ç¤ºåŠ¨ç”»å’Œæ–°ç‚¹æ•°
            setTimeout(() => {
                // æŠ–åŠ¨åŠ¨ç”»
                gameState.currentSequence.forEach(index => {
                    const diceElement = document.querySelector(`.dice[data-index="${index}"]`);
                    if (diceElement) {
                        diceElement.classList.add('shaking');
                    }
                });
                
                playSound('diceRoll');
                
                // ç”Ÿæˆæ–°ç‚¹æ•°
                setTimeout(() => {
                    gameState.currentSequence.forEach(index => {
                        gameState.diceValues[index] = Math.floor(Math.random() * 6) + 1;
                    });
                    
                    // åœæ­¢åŠ¨ç”»å¹¶æ›´æ–°æ˜¾ç¤º
                    gameState.currentSequence.forEach(index => {
                        const diceElement = document.querySelector(`.dice[data-index="${index}"]`);
                        if (diceElement) {
                            diceElement.classList.remove('shaking');
                        }
                    });
                    
                    // æ¸…é™¤é€‰ä¸­çŠ¶æ€ï¼Œä»¥ä¾¿é‡æ–°é€‰æ‹©
                    gameState.currentSequence = [];
                    
                    updateDiceDisplay();
                    
                    addLogEntry('ç³»ç»Ÿ', `AIé‡æŠ•å®Œæˆ`, 'system');
                    
                    // é‡æ–°åˆ†æå¹¶é€‰æ‹©æ‰€æœ‰æœ‰æ•ˆç»„åˆ
                    setTimeout(() => {
                        aiSelectAllValidCombinationsAfterReroll();
                    }, 1000);
                }, 500);
            }, 300);
        }
        
        function aiSelectBestCombination(bestCombinationSet) {
            // è®¾ç½®å½“å‰ç»„åˆ
            gameState.currentCombination = bestCombinationSet.combinations;
            gameState.currentSequence = bestCombinationSet.combinations.flatMap(comb => comb.indices);
            
            // æ¨¡æ‹ŸAIé€‰æ‹©éª°å­
            updateDiceDisplay();
            updateCombinationDisplay(gameState.currentCombination, true);
            
            // å»¶è¿Ÿåè®¡åˆ†
            setTimeout(() => {
                scoreAndEndTurn();
            }, 1500);
        }
        
        function aiSelectAllValidCombinationsAfterReroll() {
            // é‡æ–°åˆ†æéª°å­ï¼Œé€‰æ‹©æ‰€æœ‰æœ‰æ•ˆç»„åˆ
            const availableDice = [];
            for (let i = 0; i < gameState.diceCount; i++) {
                if (!gameState.selectedDice.includes(i)) {
                    availableDice.push({index: i, value: gameState.diceValues[i]});
                }
            }
            
            const allCombinations = findAllValidCombinationsForAI(availableDice);
            
            if (allCombinations.length > 0) {
                // é€‰æ‹©æœ€ä½³ç»„åˆé›†åˆ
                const bestCombinationSet = allCombinations[0];
                aiSelectBestCombination(bestCombinationSet);
            } else {
                // æ— æœ‰æ•ˆç»„åˆï¼Œç›´æ¥ç»“æŸ
                addLogEntry('AI', 'é‡æŠ•åæ— æœ‰æ•ˆç»„åˆï¼Œç»“æŸå›åˆ', 'ai');
                gameState.currentAICombinationString = 'æ— æœ‰æ•ˆç»„åˆ';
                setTimeout(() => endRound(), 1000);
            }
        }
        
        // ç»“æŸæ¸¸æˆ
        function endGame(winner) {
            gameState.gameActive = false;
            updateGameOverStats();
            
            // è®¾ç½®è·èƒœè€…æ–‡æœ¬å’Œæ ·å¼
            if (winner === 'player') {
                elements.winnerText.textContent = 'ç©å®¶è·èƒœ';
                elements.winnerText.className = 'player-winner-text';
                elements.winnerElement.classList.remove('ai-winner-text', 'tie-winner-text');
                elements.winnerElement.classList.add('player-winner-text');
                addLogEntry('ç³»ç»Ÿ', `æ¸¸æˆç»“æŸï¼ç©å®¶è·èƒœï¼`, 'system');
                setTimeout(() => playSound('win'), 500);
            } else if (winner === 'ai') {
                elements.winnerText.textContent = 'AIå¯¹æ‰‹è·èƒœ';
                elements.winnerText.className = 'ai-winner-text';
                elements.winnerElement.classList.remove('player-winner-text', 'tie-winner-text');
                elements.winnerElement.classList.add('ai-winner-text');
                addLogEntry('ç³»ç»Ÿ', `æ¸¸æˆç»“æŸï¼AIè·èƒœï¼`, 'system');
                setTimeout(() => playSound('lose'), 500);
            } else {
                elements.winnerText.textContent = 'å¹³å±€';
                elements.winnerText.className = 'tie-winner-text';
                elements.winnerElement.classList.remove('player-winner-text', 'ai-winner-text');
                elements.winnerElement.classList.add('tie-winner-text');
                addLogEntry('ç³»ç»Ÿ', `æ¸¸æˆç»“æŸï¼åŒæ–¹å¹³å±€ï¼`, 'system');
                setTimeout(() => playSound('win'), 500);
            }
            
            // éšè—æ¸¸æˆåŒºåŸŸï¼Œæ˜¾ç¤ºæ¸¸æˆç»“æŸå®¹å™¨
            elements.playersInfo.style.display = 'none';
            elements.diceSection.style.display = 'none';
            elements.gameOverContainer.style.display = 'flex';
            
            // ä¿ç•™æ¸¸æˆæ—¥å¿—åŒºåŸŸ
            elements.gameLogCollapsible.style.display = 'block';
        }
        
        // äº‹ä»¶ç›‘å¬
        elements.rerollBtn.addEventListener('click', rerollSelectedDice);
        elements.scoreBtn.addEventListener('click', scoreAndEndTurn);
        elements.gameOverRestartBtn.addEventListener('click', initGame);
        
        // ä¸ºæ‰€æœ‰æŒ‰é’®æ·»åŠ éŸ³æ•ˆ
        document.querySelectorAll('button').forEach(button => {
            if (button.id !== 'sound-control' && button.id !== 'score-control') {
                button.addEventListener('click', function() {
                    if (!this.disabled) playSound('buttonClick');
                });
            }
        });
        
        // åˆå§‹åŒ–æ¸¸æˆ
        initGame();
    </script>
</body>
</html>
