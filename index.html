<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dice Combo</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ²</text></svg>" type="image/svg+xml">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; -webkit-tap-highlight-color: transparent; }
        
        body { 
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); 
            color: #fff; 
            min-height: 100vh; 
            padding: 8px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: flex-start; 
            overflow-x: hidden;
            overflow-y: auto;
        }
        
        @media (min-width: 769px) {
            body { overflow-y: hidden; }
        }
        
        .container { 
            max-width: 800px; /* ä»1000pxç¼©å‡åˆ°800px */
            width: 100%; 
            background: rgba(25, 25, 35, 0.95); 
            border-radius: 12px; 
            padding: 12px; 
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5); 
            border: 1px solid #2a2a3e; 
            margin-bottom: 8px; 
            position: relative;
            overflow-y: visible;
            max-height: none;
        }
        
        .game-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; background: rgba(40, 40, 60, 0.7); border-radius: 10px; border: 1px solid #3a3a4e; overflow: hidden; min-height: 80px; padding-right: 8px; }
        
        .title-section { flex: 1; display: flex; flex-direction: column; justify-content: center; padding: 16px; background: linear-gradient(90deg, rgba(60, 60, 80, 0.8) 0%, rgba(40, 40, 60, 0.7) 100%); }
        
        .header-buttons { display: flex; gap: 8px; align-items: center; }
        
        .header-btn { background: linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%); color: #222; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-weight: bold; transition: all 0.2s ease; width: 44px; height: 44px; border-radius: 50%; font-size: 0.85rem; }
        
        .header-btn:hover { background: linear-gradient(135deg, #917cc1 0%, #ebb2db 100%); transform: scale(1.05); }
        
        .header-btn:active { transform: translateY(2px) scale(0.95); }
        
        .game-title { font-size: 1.6rem; font-weight: bold; color: #fff; display: flex; align-items: center; gap: 12px; margin-bottom: 4px; }
        
        .game-subtitle { font-size: 0.9rem; color: #ffd166; font-weight: bold; display: flex; align-items: center; gap: 6px; }
        
        .players-info { display: flex; justify-content: space-between; gap: 12px; margin-bottom: 12px; }
        
        .player-card { flex: 1; background: rgba(40, 40, 60, 0.8); border-radius: 8px; padding: 8px; border: 1px solid #3a3a4e; display: flex; align-items: center; justify-content: space-between; position: relative; }
        
        .player-card.player { border-color: #4ecdc4; }
        .player-card.ai { border-color: #ff6b6b; }
        
        .player-card.active-turn { box-shadow: 0 0 0 2px #ffd166, 0 0 15px rgba(255, 209, 102, 0.5); animation: pulse 2s infinite; }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 2px #ffd166, 0 0 15px rgba(255, 209, 102, 0.5); }
            50% { box-shadow: 0 0 0 4px #ffd166, 0 0 25px rgba(255, 209, 102, 0.8); }
            100% { box-shadow: 0 0 0 2px #ffd166, 0 0 15px rgba(255, 209, 102, 0.5); }
        }
        
        .player-left { flex: 1; }
        .player-right { display: flex; flex-direction: column; align-items: flex-end; justify-content: center; gap: 4px; }
        
        .player-card h2 { font-size: 0.8rem; margin-bottom: 8px; display: flex; align-items: center; gap: 4px; }
        
        .score { font-size: 1.5rem; font-weight: bold; line-height: 1; }
        
        .player-card.player .score { color: #4ecdc4; }
        .player-card.ai .score { color: #ff6b6b; }
        
        .round-score-left { font-size: 0.95rem; font-weight: bold; color: #ffd166; background: rgba(60, 60, 80, 0.8); padding: 3px 8px; border-radius: 4px; display: inline-block; line-height: 1; margin-top: 4px; }
        
        .game-area { display: flex; flex-direction: column; gap: 12px; }
        
        /* ç‹¬ç«‹å›åˆæŒ‡ç¤º - æ— å¤–æ¡† */
        .round-info-bar { 
            display: flex; 
            justify-content: space-between; 
            background: rgba(40, 40, 60, 0.9); 
            padding: 10px 12px; 
            border-radius: 8px; 
            border: 1px solid #3a3a4e; 
            font-weight: bold; 
            margin-bottom: 0;
        }
        
        .player-turn-round { border-color: #4ecdc4; border-width: 2px; background: rgba(78, 205, 196, 0.15); }
        .ai-turn-round { border-color: #ff6b6b; border-width: 2px; background: rgba(255, 107, 107, 0.15); }
        
        .round-display { font-size: 0.9rem; color: #fff; display: flex; align-items: center; gap: 6px; }
        
        .turn-indicator { font-size: 0.9rem; color: #ffd166; display: flex; align-items: center; gap: 6px; }
        
        /* ç‹¬ç«‹éª°å­åŒº - æ— å¤–æ¡† */
        .dice-container { 
            display: flex; 
            justify-content: center; 
            align-items: center;
            gap: 10px; 
            flex-wrap: wrap; 
            margin-bottom: 0; 
            margin-top: 0;
            padding: 8px 0;
            min-height: 90px; /* ç¡®ä¿æœ‰è¶³å¤Ÿé«˜åº¦ */
        }
        
        /* ç§»åŠ¨ç«¯éª°å­åŠ¨æ€æ”¾å¤§ - å æ»¡å®½åº¦ */
        @media (max-width: 768px) {
            .dice-container {
                justify-content: space-between;
                width: 100%;
            }
            
            /* ç¡®ä¿7ä¸ªéª°å­ç­‰æ¯”ä¾‹æ”¾å¤§åˆ°å›åˆæŒ‡ç¤ºå®½åº¦ */
            .dice-wrapper {
                flex: 1;
                min-width: auto;
                max-width: auto;
                display: flex;
                justify-content: center;
            }
            
            .dice {
                width: 100% !important;
                height: auto !important;
                aspect-ratio: 1 / 1; /* ä¿æŒæ­£æ–¹å½¢ */
            }
        }
        
        .dice-wrapper { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            gap: 4px; 
            flex-shrink: 0;
        }
        
        .dice { 
            width: 58px; 
            height: 58px; 
            background: #fff; 
            border-radius: 10px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 1.7rem; 
            color: #222; 
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3); 
            cursor: pointer; 
            transition: all 0.3s ease; 
            position: relative; 
            user-select: none; 
        }
        
        .dice:hover { transform: translateY(-2px); box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4); }
        
        .dice.selected { background: #4ecdc4; color: white; transform: scale(1.05); }
        .dice.ai-selected { background: #ff6b6b; color: white; transform: scale(1.05); }
        .dice.used { background: #555; color: #777; cursor: not-allowed; opacity: 0.5; transform: scale(0.9); }
        .dice.locked { background: #888; color: #aaa; cursor: not-allowed; opacity: 0.7; }
        
        .dice.used::after { content: "Ã—"; position: absolute; top: -4px; right: -4px; background: #ff6b6b; color: white; width: 16px; height: 16px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.8rem; font-weight: bold; }
        
        /* ä¿®å¤ï¼šé—®å·éª°å­å¿…é¡»æ˜¯ç™½è‰²ï¼Œå¹¶ä¸”ä¼˜å…ˆçº§è¦é«˜äºå…¶ä»–ç±» */
        .dice[data-value="?"] { 
            background: #fff !important; 
            color: #666 !important; 
        }
        
        /* ç¡®ä¿é—®å·éª°å­ä¸ä¼šè¢«å…¶ä»–ç±»è¦†ç›– */
        .dice[data-value="?"].used,
        .dice[data-value="?"].locked,
        .dice[data-value="?"].selected,
        .dice[data-value="?"].ai-selected {
            background: #fff !important;
            color: #666 !important;
            opacity: 1 !important;
        }
        
        /* é—®å·éª°å­å†…éƒ¨çš„é—®å·æ ·å¼ */
        .dice[data-value="?"] .dice-question {
            color: #666 !important;
        }
        
        .dice-points { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); width: 100%; height: 100%; padding: 5px; }
        
        /* PCç«¯éª°å­ç‚¹ç¨å¾®å°ä¸€ç‚¹ï¼Œä½†æ¯”æœ€åˆçš„å¤§ */
        .dot { 
            width: 9px; 
            height: 9px; 
            background-color: #222; 
            border-radius: 50%; 
            justify-self: center; 
            align-self: center; 
        }
        
        .dice.selected .dot, .dice.ai-selected .dot { background-color: white; }
        .dice.used .dot { background-color: #777; }
        .dice.locked .dot { background-color: #aaa; }
        
        .dice-1 .dot:nth-child(1) { grid-column: 2; grid-row: 2; }
        .dice-2 .dot:nth-child(1) { grid-column: 1; grid-row: 1; }
        .dice-2 .dot:nth-child(2) { grid-column: 3; grid-row: 3; }
        .dice-3 .dot:nth-child(1) { grid-column: 1; grid-row: 1; }
        .dice-3 .dot:nth-child(2) { grid-column: 2; grid-row: 2; }
        .dice-3 .dot:nth-child(3) { grid-column: 3; grid-row: 3; }
        .dice-4 .dot:nth-child(1) { grid-column: 1; grid-row: 1; }
        .dice-4 .dot:nth-child(2) { grid-column: 3; grid-row: 1; }
        .dice-4 .dot:nth-child(3) { grid-column: 1; grid-row: 3; }
        .dice-4 .dot:nth-child(4) { grid-column: 3; grid-row: 3; }
        .dice-5 .dot:nth-child(1) { grid-column: 1; grid-row: 1; }
        .dice-5 .dot:nth-child(2) { grid-column: 3; grid-row: 1; }
        .dice-5 .dot:nth-child(3) { grid-column: 2; grid-row: 2; }
        .dice-5 .dot:nth-child(4) { grid-column: 1; grid-row: 3; }
        .dice-5 .dot:nth-child(5) { grid-column: 3; grid-row: 3; }
        .dice-6 .dot:nth-child(1) { grid-column: 1; grid-row: 1; }
        .dice-6 .dot:nth-child(2) { grid-column: 1; grid-row: 2; }
        .dice-6 .dot:nth-child(3) { grid-column: 1; grid-row: 3; }
        .dice-6 .dot:nth-child(4) { grid-column: 3; grid-row: 1; }
        .dice-6 .dot:nth-child(5) { grid-column: 3; grid-row: 2; }
        .dice-6 .dot:nth-child(6) { grid-column: 3; grid-row: 3; }
        
        .dice-question { display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; font-size: 1.7rem; font-weight: bold; color: #666; }
        
        @keyframes shake {
            0% { transform: translate(0, 0) rotate(0deg); }
            10% { transform: translate(-3px, -3px) rotate(-5deg); }
            20% { transform: translate(3px, 3px) rotate(5deg); }
            30% { transform: translate(-3px, 3px) rotate(-5deg); }
            40% { transform: translate(3px, -3px) rotate(5deg); }
            50% { transform: translate(-3px, -3px) rotate(-5deg); }
            60% { transform: translate(3px, 3px) rotate(5deg); }
            70% { transform: translate(-3px, 3px) rotate(-5deg); }
            80% { transform: translate(3px, -3px) rotate(5deg); }
            90% { transform: translate(-3px, -3px) rotate(-5deg); }
            100% { transform: translate(0, 0) rotate(0deg); }
        }
        
        .dice.shaking { animation: shake 0.5s ease-in-out; }
        
        /* ç‹¬ç«‹æŒ‰é’®åŒº - æ— å¤–æ¡† */
        .controls { 
            display: grid; 
            grid-template-columns: repeat(2, 1fr); 
            gap: 12px; 
            margin-top: 0;
            width: 100%;
        }
        
        .control-btn { 
            padding: 10px 8px; 
            font-size: 0.85rem; 
            font-weight: bold; 
            border: none; 
            border-radius: 8px; 
            cursor: pointer; 
            transition: all 0.2s ease; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            gap: 5px; 
            text-align: center; 
        }
        
        .control-btn:active { transform: translateY(2px); box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2); }
        
        /* ç§»åŠ¨ç«¯è§¦æ‘¸æ¿€æ´»çŠ¶æ€ */
        .control-btn.touch-active {
            transform: translateY(2px) !important;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2) !important;
        }
        
        #confirm-continue-btn { background: linear-gradient(135deg, #4ecdc4 0%, #a8e6cf 100%); color: #222; }
        #confirm-continue-btn:hover { background: linear-gradient(135deg, #3dbdb4 0%, #98d6bf 100%); }
        
        #confirm-end-btn { background: linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%); color: #222; }
        #confirm-end-btn:hover { background: linear-gradient(135deg, #917cc1 0%, #ebb2db 100%); }
        
        button:disabled { background: #555; color: #888; cursor: not-allowed; transform: none !important; box-shadow: none !important; }
        
        .overlay { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(0, 0, 0, 0.95); 
            display: none; 
            align-items: center; 
            justify-content: center; 
            z-index: 1000; 
            animation: fadeIn 0.3s ease; 
            padding: 16px; 
        }
        
        .modal-content { 
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); 
            padding: 20px; 
            border-radius: 12px; 
            text-align: left; 
            max-width: 600px; 
            width: 100%; 
            max-height: 80vh; 
            overflow-y: auto; 
            border: 2px solid #4ecdc4; 
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.7); 
            position: relative;
        }
        
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        
        .modal-title { font-size: 1.4rem; color: #ffd166; display: flex; align-items: center; gap: 10px; }
        
        .overlay-close-hint { 
            position: fixed; 
            bottom: 30px; 
            left: 50%; 
            transform: translateX(-50%); 
            color: rgba(255, 255, 255, 0.7); 
            font-size: 0.9rem; 
            text-align: center; 
            width: 100%; 
            padding: 10px; 
            display: none; 
            z-index: 1001; 
        }
        
        .rules-section { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        .rules-section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        
        .rules-section-title { font-size: 1.1rem; color: #ffd166; margin-bottom: 12px; padding-left: 8px; border-left: 4px solid #a18cd1; display: flex; align-items: center; gap: 8px; }
        .rules-section-title i { width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; background: rgba(161, 140, 209, 0.2); border: 1px solid rgba(161, 140, 209, 0.4); border-radius: 4px; }
        
        .rules-list { padding-left: 20px; margin-bottom: 10px; font-size: 0.9rem; }
        .rules-list li { margin-bottom: 8px; position: relative; }
        .rules-list li::before { content: "â€¢"; color: #4ecdc4; font-weight: bold; position: absolute; left: -15px; }
        
        .rules-highlight { background: rgba(255, 209, 102, 0.15); padding: 12px; border-radius: 8px; border-left: 4px solid #ffd166; margin: 12px 0; }
        .rules-highlight-title { color: #ffd166; font-weight: bold; margin-bottom: 6px; display: flex; align-items: center; gap: 6px; }
        .rules-highlight-title i { width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; background: rgba(255, 209, 102, 0.2); border: 1px solid rgba(255, 209, 102, 0.4); border-radius: 4px; }
        
        .rules-warning { background: rgba(255, 107, 107, 0.15); padding: 12px; border-radius: 8px; border-left: 4px solid #ff6b6b; margin: 12px 0; }
        .rules-warning-title { color: #ff6b6b; font-weight: bold; margin-bottom: 6px; display: flex; align-items: center; gap: 6px; }
        .rules-warning-title i { width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; background: rgba(255, 107, 107, 0.2); border: 1px solid rgba(255, 107, 107, 0.4); border-radius: 4px; }
        
        .rules-example { background: rgba(78, 205, 196, 0.1); padding: 10px; border-radius: 6px; margin: 8px 0; font-style: italic; border-left: 3px solid #4ecdc4; }
        
        .highlight { color: #ffd166; font-weight: bold; }
        .warning { color: #ff6b6b; font-weight: bold; }
        .important { color: #4ecdc4; font-weight: bold; }
        
        /* ===== å®Œå…¨é‡æ–°è®¾è®¡å†å²è®°å½•å¼¹çª—æ ·å¼ ===== */
        .history-modal-content {
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
        }
        
        .history-header-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .history-nav {
            display: flex;
            align-items: center;
            gap: 15px;
            justify-content: center;
            flex: 1;
        }
        
        .history-nav-btn {
            background: linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%);
            color: #222;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.2s ease;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1rem;
        }
        
        .history-nav-btn:hover {
            background: linear-gradient(135deg, #917cc1 0%, #ebb2db 100%);
            transform: scale(1.05);
        }
        
        .history-nav-btn:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .history-time-display {
            font-size: 1rem;
            color: #ffd166;
            font-weight: bold;
            text-align: center;
            min-width: 200px;
        }
        
        .history-table-container {
            margin-top: 15px;
            overflow: auto;
            border-radius: 8px;
            border: 1px solid #3a3a4e;
            max-height: calc(90vh - 180px);
            display: flex;
            flex-direction: column;
        }
        
        /* é‡æ–°è®¾è®¡å†å²è®°å½•è¡¨æ ¼ */
        .history-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            table-layout: fixed;
        }
        
        .history-table thead {
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        /* è¡¨å¤´åˆ—å®½åˆ†é… */
        .history-table th {
            background: rgba(60, 60, 80, 0.95);
            color: #ffd166;
            padding: 12px 6px;
            text-align: center;
            font-size: 0.9rem;
            border-bottom: 2px solid rgba(255, 209, 102, 0.3);
            position: sticky;
            top: 0;
        }
        
        .history-table th:nth-child(1) { width: 8%; }
        .history-table th:nth-child(2) { width: 10%; }
        .history-table th:nth-child(3) { width: 50%; }
        .history-table th:nth-child(4) { width: 12%; }
        .history-table th:nth-child(5) { width: 12%; }
        
        /* è¡¨æ ¼ä¸»ä½“æ ·å¼ */
        .history-table tbody tr {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .history-table tbody tr:last-child {
            border-bottom: none;
        }
        
        .history-table td {
            padding: 10px 6px;
            vertical-align: middle;
            text-align: center;
            font-weight: bold;
        }
        
        /* å›åˆå•å…ƒæ ¼ */
        .player-row .round-number-cell {
            text-align: center;
            font-weight: bold;
            color: #ffd166;
            vertical-align: middle;
        }
        
        /* ç©å®¶è¡Œæ ·å¼ */
        .player-row td {
            background: rgba(40, 40, 60, 0.8);
            color: #4ecdc4;
        }
        
        .player-row td:nth-child(2) {
            text-align: center;
            font-weight: bold;
        }
        
        .player-row td:nth-child(3) {
            text-align: center;
            font-weight: bold;
            word-break: break-word;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .player-row td:nth-child(4),
        .player-row td:nth-child(5) {
            text-align: center;
            font-weight: bold;
        }
        
        /* AIè¡Œæ ·å¼ */
        .ai-row td {
            background: rgba(40, 40, 60, 0.8);
            color: #ff6b6b;
        }
        
        .ai-row td:nth-child(1) {
            text-align: center;
            font-weight: bold;
        }
        
        .ai-row td:nth-child(2) {
            text-align: center;
            font-weight: bold;
            word-break: break-word;
            padding-left: 10px;
            padding-right: 10px;
        }
        
        .ai-row td:nth-child(3),
        .ai-row td:nth-child(4) {
            text-align: center;
            font-weight: bold;
        }
        
        /* æ‚¬åœæ•ˆæœ */
        .history-table tbody tr:hover td {
            background: rgba(255, 255, 255, 0.05);
        }
        
        /* æƒ©ç½šæ–‡æœ¬æ ·å¼ */
        .penalty-text {
            color: #ff6b6b;
            font-weight: bold;
        }
        
        .penalty-popup { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #ff6b6b 0%, #ff8e8e 100%); color: white; padding: 16px; border-radius: 10px; z-index: 200; text-align: center; box-shadow: 0 6px 20px rgba(255, 107, 107, 0.5); display: none; animation: popIn 0.5s ease-out; }
        
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            70% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        .game-over { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); display: none; align-items: center; justify-content: center; z-index: 100; animation: fadeIn 0.5s ease; padding: 16px; flex-direction: column; }
        
        .game-over-content { 
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); 
            padding: 20px; 
            border-radius: 12px; 
            text-align: center; 
            max-width: 800px; 
            width: 100%; 
            max-height: 70vh; 
            overflow-y: auto; 
            border: 2px solid #4ecdc4; 
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.7); 
            margin-bottom: 20px; 
        }
        
        .game-over-header { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            margin-bottom: 20px; 
            padding-bottom: 15px; 
            border-bottom: 1px solid rgba(255, 255, 255, 0.1); 
        }
        
        .game-over h2 { 
            font-size: 1.8rem; 
            margin-bottom: 8px; 
            color: #ffd166; 
            display: flex; 
            align-items: center; 
            gap: 10px; 
        }
        
        .winner-message { 
            font-size: 1.8rem; 
            margin-bottom: 12px; 
            padding: 8px 16px; 
            border-radius: 8px; 
            font-weight: bold; 
            color: #ffd166 !important; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            gap: 15px;
        }
        
        .final-score-display { 
            display: flex; 
            justify-content: center; 
            align-items: center;
            gap: 20px; 
            margin: 15px 0; 
            font-size: 1.5rem;
        }
        
        .final-player-score { 
            color: #4ecdc4; 
            font-weight: bold; 
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .final-ai-score { 
            color: #ff6b6b; 
            font-weight: bold; 
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .final-score-divider {
            color: #ffd166;
            font-weight: bold;
            font-size: 1.8rem;
        }
        
        .total-rounds-display {
            font-size: 1.1rem;
            color: #ffd166;
            margin-top: 10px;
            font-weight: bold;
            background: rgba(60, 60, 80, 0.8);
            padding: 8px 16px;
            border-radius: 8px;
        }
        
        .stats-table-container { margin-top: 15px; overflow-x: auto; }
        .stats-table { width: 100%; border-collapse: collapse; font-size: 0.9rem; background: rgba(40, 40, 60, 0.8); border-radius: 8px; overflow: hidden; }
        
        .stats-table th { background: rgba(60, 60, 80, 0.9); color: #ffd166; padding: 10px; text-align: center; font-weight: bold; border-bottom: 2px solid rgba(255, 255, 255, 0.1); }
        .stats-table td { padding: 10px; text-align: center; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        .stats-table tr:last-child td { border-bottom: none; }
        .stats-table tr:hover { background: rgba(255, 255, 255, 0.05); }
        
        .player-stats-row td:first-child { color: #4ecdc4; font-weight: bold; }
        .ai-stats-row td:first-child { color: #ff6b6b; font-weight: bold; }
        .stats-value-cell { font-weight: bold; font-size: 1.1rem; }
        
        .game-over-buttons { display: flex; justify-content: center; gap: 12px; margin-top: 20px; flex-wrap: wrap; }
        
        #restart-btn { background: linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%); color: #222; font-size: 1rem; padding: 12px 24px; min-width: 200px; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; gap: 8px; font-weight: bold; }
        
        #game-over-history-btn { background: linear-gradient(135deg, #4ecdc4 0%, #a8e6cf 100%); color: #222; font-size: 1rem; padding: 12px 24px; min-width: 200px; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; gap: 8px; font-weight: bold; }
        
        /* ===== è®¡åˆ†è¡¨åŒºåŸŸæ ·å¼ ===== */
        .score-table-container {
            background: rgba(30, 30, 50, 0.8);
            padding: 12px;
            border-radius: 10px;
            border: 1px solid #3a3a5e;
            position: relative;
            min-height: 200px;
        }
        
        .score-table-title {
            font-size: 0.9rem;
            color: #ffd166;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        /* PCç«¯ï¼š3è¡Œ4åˆ— */
        .score-table-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(3, auto);
            gap: 8px;
        }
        
        /* ç§»åŠ¨ç«¯ï¼š4è¡Œ3åˆ— */
        @media (max-width: 768px) {
            .score-table-grid {
                grid-template-columns: repeat(3, 1fr);
                grid-template-rows: repeat(4, auto);
                gap: 6px;
            }
        }
        
        .score-table-item {
            background: rgba(40, 40, 60, 0.8);
            border-radius: 8px;
            padding: 10px;
            border: 1px solid #3a3a4e;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            transition: all 0.2s ease;
            min-height: 50px;
            position: relative;
        }
        
        .score-table-item.active {
            background: rgba(78, 205, 196, 0.2);
            border-color: #4ecdc4;
            box-shadow: 0 0 8px rgba(78, 205, 196, 0.5);
            transform: scale(1.02);
        }
        
        .score-table-item.ai-active {
            background: rgba(255, 107, 107, 0.2);
            border-color: #ff6b6b;
            box-shadow: 0 0 8px rgba(255, 107, 107, 0.5);
            transform: scale(1.02);
        }
        
        .score-table-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            font-size: 0.9rem;
            margin-right: 8px;
            flex-shrink: 0;
        }
        
        .score-table-icon.sequence {
            background: linear-gradient(135deg, #4ecdc4 0%, #a8e6cf 100%);
            color: #222;
        }
        
        .score-table-icon.same {
            background: linear-gradient(135deg, #ff6b6b 0%, #ff8e8e 100%);
            color: white;
        }
        
        .score-table-name {
            font-size: 0.85rem;
            font-weight: bold;
            color: #fff;
            text-align: left;
            flex-grow: 1;
        }
        
        .score-table-points {
            font-size: 1rem;
            font-weight: bold;
            color: #ffd166;
            margin-left: auto;
            text-align: right;
        }
        
        /* è§’æ ‡æ ·å¼ */
        .score-table-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 18px;
            height: 18px;
            background: #ffd166;
            color: #222;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            z-index: 2;
        }
        
        /* ç‰ˆæƒä¿¡æ¯ */
        .game-credit { 
            position: absolute; 
            bottom: 12px; 
            right: 12px; 
            font-size: 0.7rem; 
            color: rgba(255, 255, 255, 0.5); 
            text-align: right; 
            z-index: 1; 
        }
        
        /* å“åº”å¼è®¾è®¡ä¼˜åŒ– */
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .game-title { font-size: 1.4rem; }
            .game-subtitle { font-size: 0.8rem; }
            .players-info { flex-direction: row; }
            .player-card { width: 100%; }
            
            /* ç§»åŠ¨ç«¯éª°å­åŠ¨æ€ç­‰æ¯”æ”¾å¤§ */
            .dice { 
                font-size: 1.4rem; 
            }
            
            .dice-question { font-size: 1.4rem; }
            .dice-points { padding: 4px; }
            
            /* ç§»åŠ¨ç«¯éª°å­ç‚¹çš„å¤§å° */
            .dice .dot,
            .dice-points .dot { 
                width: 7px !important; 
                height: 7px !important; 
            }
            
            .dice-container { 
                gap: 3px; 
                padding: 3px 0;
                min-height: 70px;
                justify-content: space-between;
            }

            .controls {
                gap: 6px;  /* ç§»åŠ¨ç«¯ç¨å¾®å°ä¸€ç‚¹ï¼Œå› ä¸ºå±å¹•è¾ƒå° */
            }
            
            .control-btn { font-size: 0.8rem; padding: 8px 6px; }
            .header-btn { width: 40px; height: 40px; font-size: 0.75rem; }
            .game-over-content { padding: 15px; max-height: 60vh; }
            .game-over h2 { font-size: 1.5rem; }
            .winner-message { font-size: 1.5rem; gap: 10px; }
            .final-score-display { font-size: 1.2rem; gap: 15px; }
            .round-score-left { font-size: 0.9rem; padding: 2px 6px; }
            .round-display, .turn-indicator { font-size: 0.8rem; }
            .modal-content { padding: 15px; max-height: 60vh; }
            .modal-title { font-size: 1.2rem; }
            .overlay-close-hint { font-size: 0.8rem; bottom: 20px; }
            .history-table { font-size: 0.75rem; }
            .history-table th, .history-table td { padding: 8px 4px; }
            .game-over-buttons { flex-direction: column; align-items: center; }
            #restart-btn, #game-over-history-btn { min-width: 180px; width: 100%; max-width: 250px; }
            .rules-section-title { font-size: 1rem; }
            .rules-content { font-size: 0.85rem; }
            .total-rounds-display { font-size: 1rem; padding: 6px 12px; }
            .game-header { min-height: 70px; }
            .title-section { padding: 12px; }
            .score-table-item { padding: 8px; min-height: 45px; }
            .score-table-icon { width: 22px; height: 22px; font-size: 0.8rem; }
            .score-table-name { font-size: 0.8rem; }
            .score-table-points { font-size: 0.9rem; }
            .score-table-badge { width: 16px; height: 16px; font-size: 0.65rem; }
            .game-credit { bottom: 10px; right: 10px; font-size: 0.65rem; }
            
            /* å†å²è®°å½•å¼¹çª—å“åº”å¼ */
            .history-modal-content {
                max-width: 95%;
                width: 95%;
                max-height: 85vh;
            }
            
            .history-table-container {
                max-height: calc(85vh - 180px);
            }
            
            .history-time-display {
                font-size: 0.9rem;
                min-width: 150px;
            }
            
            .history-nav-btn {
                width: 36px;
                height: 36px;
                font-size: 0.9rem;
            }
            
            .history-nav {
                gap: 10px;
            }
            
            /* ç§»åŠ¨ç«¯è¡¨æ ¼åˆ—å®½è°ƒæ•´ */
            .history-table th:nth-child(1) { width: 10%; }
            .history-table th:nth-child(2) { width: 12%; }
            .history-table th:nth-child(3) { width: 48%; }
            .history-table th:nth-child(4) { width: 12%; }
            .history-table th:nth-child(5) { width: 12%; }
        }
        
        @media (max-width: 480px) {
            .dice { 
                font-size: 1.3rem; 
            }
            
            .dice-question { font-size: 1.3rem; }
            .dot { width: 6px; height: 6px; }
            .dice-container { gap: 4px; }
            .game-header { min-height: auto; padding-right: 8px; }
            .title-section { padding: 10px; }
            .header-buttons { gap: 6px; }
            .header-btn { width: 38px; height: 38px; font-size: 0.7rem; }
            .round-score-left { font-size: 0.85rem; padding: 2px 4px; }
            .history-table { font-size: 0.7rem; }
            .history-table th, .history-table td { padding: 6px 3px; }
            .overlay-close-hint { font-size: 0.75rem; bottom: 15px; }
            .players-info { gap: 6px; }
            .player-card { padding: 6px; }
            .score-table-item { padding: 6px; min-height: 40px; }
            .score-table-icon { width: 20px; height: 20px; font-size: 0.75rem; }
            .score-table-name { font-size: 0.75rem; }
            .score-table-points { font-size: 0.85rem; }
            .score-table-badge { width: 15px; height: 15px; font-size: 0.6rem; }
            .winner-message { font-size: 1.3rem; gap: 8px; }
            .final-score-display { font-size: 1rem; gap: 10px; }
            .game-credit { font-size: 0.6rem; }
            
            /* å†å²è®°å½•å¼¹çª—å“åº”å¼ */
            .history-time-display {
                font-size: 0.8rem;
                min-width: 120px;
            }
            
            .history-nav-btn {
                width: 32px;
                height: 32px;
                font-size: 0.8rem;
            }
        }
        
        /* PCç«¯éª°å­æ›´å¤§ï¼Œç‚¹ç¨å¾®å°ä¸€ç‚¹ */
        @media (min-width: 769px) {
            .dice { width: 62px; height: 62px; font-size: 1.9rem; }
            .dice-question { font-size: 1.9rem; }
            .dice-points { padding: 7px; }
            .dot { width: 10px; height: 10px; }
        }
        
        .log-content::-webkit-scrollbar, .modal-content::-webkit-scrollbar { width: 6px; }
        .log-content::-webkit-scrollbar-track, .modal-content::-webkit-scrollbar-track { background: rgba(60, 60, 80, 0.5); border-radius: 3px; }
        .log-content::-webkit-scrollbar-thumb, .modal-content::-webkit-scrollbar-thumb { background: #ffd166; border-radius: 3px; }
        
        /* å†å²è®°å½•è¡¨æ ¼æ»šåŠ¨æ¡ */
        .history-table-container::-webkit-scrollbar { width: 6px; }
        .history-table-container::-webkit-scrollbar-track { background: rgba(60, 60, 80, 0.5); border-radius: 3px; }
        .history-table-container::-webkit-scrollbar-thumb { background: #ffd166; border-radius: 3px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="game-header">
            <div class="title-section">
                <div class="game-title">Dice Combo ğŸ²</div>
                <div class="game-subtitle"><i class="fas fa-bullseye"></i> ç›®æ ‡åˆ†æ•°: <span id="target-score">700</span></div>
            </div>
            <div class="header-buttons">
                <!-- è§„åˆ™æŒ‰é’®åœ¨å·¦ï¼Œå†å²æŒ‰é’®åœ¨å³ -->
                <button class="header-btn" id="rules-button" title="æ¸¸æˆè§„åˆ™">
                    <i class="fas fa-book"></i>
                </button>
                <button class="header-btn" id="history-button" title="å†å²è®°å½•">
                    <i class="fas fa-history"></i>
                </button>
            </div>
        </div>
        
        <div class="players-info">
            <div class="player-card player" id="player-card">
                <div class="player-left">
                    <h2><i class="fas fa-user"></i> ç©å®¶</h2>
                    <div class="round-score-left" id="player-round-score-left">æœ¬å›åˆ: 0</div>
                </div>
                <div class="player-right">
                    <div class="score-container">
                        <div class="score player-score">0</div>
                    </div>
                </div>
            </div>
            
            <div class="player-card ai" id="ai-card">
                <div class="player-left">
                    <h2><i class="fas fa-robot"></i> AIå¯¹æ‰‹</h2>
                    <div class="round-score-left" id="ai-round-score-left">æœ¬å›åˆ: 0</div>
                </div>
                <div class="player-right">
                    <div class="score-container">
                        <div class="score ai-score">0</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="game-area">
            <!-- ç‹¬ç«‹å›åˆæŒ‡ç¤º -->
            <div class="round-info-bar" id="round-info-bar">
                <div class="round-display">
                    <i class="fas fa-flag"></i> ç¬¬<span id="round-number">1</span>å›åˆ
                </div>
                <div class="turn-indicator" id="turn-indicator-text">
                    <i class="fas fa-user"></i> ç©å®¶å›åˆ
                </div>
            </div>
            
            <!-- ç‹¬ç«‹éª°å­åŒº -->
            <div class="dice-container" id="dice-container"></div>
            
            <!-- ç‹¬ç«‹æŒ‰é’®åŒº -->
            <div class="controls">
                <button id="confirm-continue-btn" class="control-btn" disabled>
                    <i class="fas fa-redo"></i> è®¡åˆ†å¹¶å†æ¬¡æŠ•æ·
                </button>
                <button id="confirm-end-btn" class="control-btn" disabled>
                    <i class="fas fa-flag-checkered"></i> è®¡åˆ†å¹¶ç»“æŸå›åˆ
                </button>
            </div>
            
            <!-- è®¡åˆ†è¡¨åŒºåŸŸ -->
            <div class="score-table-container">
                <h3 class="score-table-title"><i class="fas fa-table"></i> è®¡åˆ†è¡¨</h3>
                <div class="score-table-grid" id="score-table-grid">
                    <!-- è®¡åˆ†è¡¨å†…å®¹å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
                </div>
                <!-- ç‰ˆæƒä¿¡æ¯æ”¾åœ¨è®¡åˆ†è¡¨å®¹å™¨å³ä¸‹è§’ -->
                <div class="game-credit">A game by Wes</div>
            </div>
        </div>
    </div>
    
    <!-- è§„åˆ™å¼¹çª— -->
    <div class="overlay" id="rules-overlay">
        <div class="modal-content" id="rules-modal-content">
            <div class="modal-header">
                <h2 class="modal-title"><i class="fas fa-book"></i> æ¸¸æˆè§„åˆ™</h2>
            </div>
            <div class="rules-content">
                <div class="rules-section">
                    <h3 class="rules-section-title"><i class="fas fa-gamepad"></i> æ ¸å¿ƒæ“ä½œ</h3>
                    <ul class="rules-list">
                        <li>æ¯å›åˆè‡ªåŠ¨æŠ•æ·éª°å­ï¼Œéœ€æŒ‰ç‚¹æ•°<span class="important">ä»å°åˆ°å¤§</span>ç‚¹å‡»é€‰éª°</li>
                        <li>å†æ¬¡ç‚¹å‡»å·²é€‰éª°å­å¯å–æ¶ˆé€‰æ‹©</li>
                    </ul>
                </div>
                
                <div class="rules-section">
                    <h3 class="rules-section-title"><i class="fas fa-calculator"></i> åˆ†ç»„è®¡åˆ†</h3>
                    <ul class="rules-list">
                        <li><span class="important">3 ä¸ªåŠä»¥ä¸Šè¿ç»­ç‚¹æ•°</span>ä¸ºè¿ç»­æ•°</li>
                        <li><span class="important">2 ä¸ªåŠä»¥ä¸Šç›¸åŒç‚¹æ•°</span>ä¸ºå æ•°</li>
                        <li>æŒ‰ç»„åˆç±»å‹ä¸å¤§å°è®¡åˆ†ï¼ˆè¯¦è§è®¡åˆ†è¡¨ï¼‰ï¼Œå¤šä¸ªç»„åˆå¯ä»¥åŒæ—¶è®¡åˆ†</li>
                    </ul>
                </div>
                
                <div class="rules-section">
                    <h3 class="rules-section-title"><i class="fas fa-play-circle"></i> æŒ‰é’®åŠŸèƒ½</h3>
                    <ul class="rules-list">
                        <li><span class="important">ã€è®¡åˆ†å¹¶å†æ¬¡æŠ•æ·ã€ï¼š</span>å½“å‰ç»„åˆè®¡åˆ†ï¼Œç»§ç»­æŠ•å‰©ä½™éª°å­</li>
                        <li><span class="important">ã€è®¡åˆ†å¹¶ç»“æŸå›åˆã€ï¼š</span>å½“å‰ç»„åˆè®¡åˆ†ï¼Œç›´æ¥ç»“æŸæœ¬å›åˆ</li>
                    </ul>
                </div>
                
                <div class="rules-section">
                    <h3 class="rules-section-title"><i class="fas fa-star"></i> ç‰¹æ®Šè§„åˆ™</h3>
                    <ul class="rules-list">
                        <li><span class="warning">å‰©ä½™ 1 ä¸ªéª°å­æ— æ³•æˆç»„</span>ï¼Œéœ€ç‚¹å‡»ã€è®¡åˆ†å¹¶ç»“æŸå›åˆã€</li>
                        <li>ç‚¹å‡»ã€è®¡åˆ†å¹¶å†æ¬¡æŠ•æ·ã€åï¼Œè‹¥é‡æ–°æŠ•æ·çš„éª°å­<span class="warning">æ— æœ‰æ•ˆç»„åˆ</span> â†’ <span class="warning">æœ¬å›åˆåˆ†æ•°ä½œåºŸ</span></li>
                        <li>è‹¥åœºä¸Šéª°å­<span class="important">å…¨éƒ¨è®¡åˆ†ï¼ˆæ¸…ç›˜ï¼‰</span>ï¼Œå¯ç‚¹å‡»ã€è®¡åˆ†å¹¶å†æ¬¡æŠ•æ·ã€è®¡åˆ†å¹¶æŠ•æ·ä¸€è½®æ–°éª°å­ï¼Œå¯å¾ªç¯ä½¿ç”¨</li>
                    </ul>
                </div>
                
                <div class="rules-section">
                    <h3 class="rules-section-title"><i class="fas fa-flag-checkered"></i> èƒœåˆ©æ¡ä»¶</h3>
                        <ul class="rules-list">
                            <li>åŒæ–¹ç©å®¶<span class="important">äº¤æ›¿è¿›è¡Œè®¡åˆ†</span>ç»„æˆä¸€ä¸ªå®Œæ•´å›åˆ</li>
                            <li><span class="important">åæ‰‹ç©å®¶</span>è¾¾åˆ°ç›®æ ‡åˆ†æ•°ç›´æ¥è·èƒœï¼Œ<span class="important">å…ˆæ‰‹ç©å®¶</span>è¾¾åˆ°ç›®æ ‡åˆ†éœ€<span class="important">ç­‰å¾…</span>åæ‰‹ç©å®¶å®Œæˆæœ¬å›åˆ</li>
                            <li>åŒæ–¹å‡è¶…è¿‡ç›®æ ‡åˆ™åˆ†æ•°æ›´é«˜è€…èƒœã€åŒåˆ†ä¸ºå¹³å±€</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="overlay-close-hint" id="rules-close-hint">ç‚¹å‡»ç©ºç™½å¤„è¿”å›</div>
    </div>
    
    <!-- å†å²è®°å½•å¼¹çª— -->
    <div class="overlay round-history-modal" id="history-overlay">
        <div class="modal-content history-modal-content" id="history-modal-content">
            <div class="history-header-controls">
                <div class="history-nav">
                    <button class="history-nav-btn" id="history-left-btn" title="ä¸Šä¸€ä¸ªè®°å½•">
                        <i class="fas fa-chevron-left"></i>
                    </button>
                    <div class="history-time-display" id="history-time-display">
                        å½“å‰æ¸¸æˆ
                    </div>
                    <button class="history-nav-btn" id="history-right-btn" title="ä¸‹ä¸€ä¸ªè®°å½•">
                        <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
            </div>
            
            <div class="history-table-container">
                <table class="history-table" id="history-table">
                    <thead>
                        <tr>
                            <th>å›åˆ</th>
                            <th>é€‰æ‰‹</th>
                            <th>ç»„åˆè¯¦æƒ…</th>
                            <th>å¾—åˆ†</th>
                            <th>ç´¯è®¡</th>
                        </tr>
                    </thead>
                    <tbody id="history-body"></tbody>
                </table>
            </div>
        </div>
        <div class="overlay-close-hint" id="history-close-hint">ç‚¹å‡»ç©ºç™½å¤„è¿”å›</div>
    </div>
    
    <div class="penalty-popup" id="penalty-popup">
        <div class="penalty-title">
            <i class="fas fa-exclamation-triangle"></i> æƒ©ç½šï¼
        </div>
        <div class="penalty-message" id="penalty-message">
            æœ¬å›åˆåˆ†æ•°ä½œåºŸ
        </div>
        <div class="penalty-score" id="penalty-score">
            æŸå¤±åˆ†æ•°: 0
        </div>
    </div>
    
    <div class="game-over" id="game-over">
        <div class="game-over-content">
            <div class="game-over-header">
                <div class="winner-message" id="winner-message">
                    <i class="fas fa-trophy"></i> <span id="winner-text">ç©å®¶è·èƒœ</span> <i class="fas fa-trophy"></i>
                </div>
                <div class="final-score-display">
                    <span class="final-player-score">
                        <i class="fas fa-user"></i> ç©å®¶ <span id="final-player-score">0</span>
                    </span>
                    <span class="final-score-divider">-</span>
                    <span class="final-ai-score">
                        <span id="final-ai-score">0</span> AI <i class="fas fa-robot"></i>
                    </span>
                </div>
                <div class="total-rounds-display" id="total-rounds-display">æ€»å›åˆæ•°: 0</div>
            </div>
            
            <div class="stats-table-container">
                <table class="stats-table">
                    <thead>
                        <tr>
                            <th>ç»Ÿè®¡é¡¹</th>
                            <th>ç©å®¶</th>
                            <th>AIå¯¹æ‰‹</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="player-stats-row">
                            <td>å¹³å‡æ¯å›åˆå¾—åˆ†</td>
                            <td class="stats-value-cell" id="player-avg-score">0</td>
                            <td class="stats-value-cell" id="ai-avg-score">0</td>
                        </tr>
                        <tr class="ai-stats-row">
                            <td>æœ€é«˜å•å›åˆå¾—åˆ†</td>
                            <td class="stats-value-cell" id="player-max-score">0</td>
                            <td class="stats-value-cell" id="ai-max-score">0</td>
                        </tr>
                        <tr class="player-stats-row">
                            <td>éª°å­å…¨è®¡åˆ†æ¬¡æ•°</td>
                            <td class="stats-value-cell" id="player-full-clear">0</td>
                            <td class="stats-value-cell" id="ai-full-clear">0</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        <div class="game-over-buttons">
            <button id="restart-btn" class="control-btn">
                <i class="fas fa-redo"></i> é‡æ–°å¼€å§‹æ¸¸æˆ
            </button>
            <button id="game-over-history-btn" class="control-btn">
                <i class="fas fa-history"></i> æŸ¥çœ‹å†å²è®°å½•
            </button>
        </div>
    </div>

    <script>
        // æ¸¸æˆçŠ¶æ€å˜é‡
        const gameState = {
            playerScore: 0,
            aiScore: 0,
            targetScore: 700,
            currentPlayer: 'player',
            diceValues: [],
            selectedDice: [],
            currentSequence: [],
            roundScore: 0,
            gameActive: true,
            roundActive: false,
            diceCount: 7,
            canSelectNewSequence: true,
            currentCombination: [],
            currentRound: 1,
            playerRoundScore: 0,
            aiRoundScore: 0,
            roundCompleted: false,
            gameHistory: [],
            currentPlayerCombinationString: '',
            currentAICombinationString: '',
            playerPenaltyThisRound: false,
            aiPenaltyThisRound: false,
            audioInitialized: false,
            playerFullClearCount: 0,
            aiFullClearCount: 0
        };
        
        // å†å²è®°å½•å­˜å‚¨
        const historyManager = {
            storageKey: 'diceComboHistory',
            maxHistoryCount: 10,
            currentHistoryIndex: 0,
            historyList: [],
            currentGameHistory: null, // å½“å‰æ¸¸æˆå†å²è®°å½•ï¼ˆä¸´æ—¶ï¼‰
            
            // ä»æœ¬åœ°å­˜å‚¨åŠ è½½å†å²è®°å½•
            loadHistory: function() {
                try {
                    const stored = localStorage.getItem(this.storageKey);
                    if (stored) {
                        this.historyList = JSON.parse(stored);
                        // ç¡®ä¿å†å²è®°å½•æ•°é‡ä¸è¶…è¿‡æœ€å¤§å€¼
                        if (this.historyList.length > this.maxHistoryCount) {
                            this.historyList = this.historyList.slice(0, this.maxHistoryCount);
                        }
                    } else {
                        this.historyList = [];
                    }
                } catch (e) {
                    console.error("åŠ è½½å†å²è®°å½•å¤±è´¥:", e);
                    this.historyList = [];
                }
            },
            
            // ä¿å­˜å†å²è®°å½•åˆ°æœ¬åœ°å­˜å‚¨
            saveHistory: function() {
                try {
                    localStorage.setItem(this.storageKey, JSON.stringify(this.historyList));
                } catch (e) {
                    console.error("ä¿å­˜å†å²è®°å½•å¤±è´¥:", e);
                }
            },
            
            // è®¾ç½®å½“å‰æ¸¸æˆå†å²è®°å½•
            setCurrentGameHistory: function(gameData) {
                this.currentGameHistory = {
                    id: 'current',
                    timestamp: new Date().toISOString(),
                    date: 'å½“å‰æ¸¸æˆ',
                    playerScore: gameData.playerScore,
                    aiScore: gameData.aiScore,
                    winner: gameData.winner,
                    winnerText: gameData.winnerText,
                    totalRounds: gameData.totalRounds,
                    playerAvgScore: gameData.playerAvgScore,
                    aiAvgScore: gameData.aiAvgScore,
                    playerMaxScore: gameData.playerMaxScore,
                    aiMaxScore: gameData.aiMaxScore,
                    playerFullClear: gameData.playerFullClear,
                    aiFullClear: gameData.aiFullClear,
                    rounds: [...gameData.rounds]
                };
            },
            
            // æ·»åŠ å†å²è®°å½•åˆ°å­˜å‚¨åˆ—è¡¨
            addHistory: function(gameData) {
                const historyEntry = {
                    id: Date.now(),
                    timestamp: new Date().toISOString(),
                    date: this.formatDate(new Date()),
                    playerScore: gameData.playerScore,
                    aiScore: gameData.aiScore,
                    winner: gameData.winner,
                    winnerText: gameData.winnerText,
                    totalRounds: gameData.totalRounds,
                    playerAvgScore: gameData.playerAvgScore,
                    aiAvgScore: gameData.aiAvgScore,
                    playerMaxScore: gameData.playerMaxScore,
                    aiMaxScore: gameData.aiMaxScore,
                    playerFullClear: gameData.playerFullClear,
                    aiFullClear: gameData.aiFullClear,
                    rounds: [...gameData.rounds]
                };
                
                // æ·»åŠ åˆ°å†å²åˆ—è¡¨å¼€å¤´
                this.historyList.unshift(historyEntry);
                
                // é™åˆ¶å†å²è®°å½•æ•°é‡
                if (this.historyList.length > this.maxHistoryCount) {
                    this.historyList = this.historyList.slice(0, this.maxHistoryCount);
                }
                
                // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
                this.saveHistory();
                
                // æ¸…ç©ºå½“å‰æ¸¸æˆå†å²è®°å½•
                this.currentGameHistory = null;
            },
            
            // æ ¼å¼åŒ–æ—¥æœŸ
            formatDate: function(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                return `${year}/${month}/${day} ${hours}:${minutes}`;
            },
            
            // è·å–æ‰€æœ‰å¯æ˜¾ç¤ºçš„å†å²è®°å½•ï¼ˆå½“å‰æ¸¸æˆ+å­˜å‚¨çš„å†å²ï¼‰
            getAllDisplayHistories: function() {
                const displayList = [];
                
                // å¦‚æœæœ‰å½“å‰æ¸¸æˆå†å²è®°å½•ï¼Œæ·»åŠ åˆ°æ˜¾ç¤ºåˆ—è¡¨
                if (this.currentGameHistory) {
                    displayList.push(this.currentGameHistory);
                }
                
                // æ·»åŠ å­˜å‚¨çš„å†å²è®°å½•
                displayList.push(...this.historyList);
                
                return displayList;
            },
            
            // è·å–å½“å‰æ˜¾ç¤ºçš„å†å²è®°å½•
            getCurrentHistory: function() {
                const displayList = this.getAllDisplayHistories();
                if (displayList.length === 0) return null;
                return displayList[this.currentHistoryIndex];
            },
            
            // å¯¼èˆªåˆ°ä¸Šä¸€ä¸ªå†å²è®°å½•
            getPrevHistory: function() {
                const displayList = this.getAllDisplayHistories();
                if (displayList.length === 0) return null;
                
                this.currentHistoryIndex = (this.currentHistoryIndex + 1) % displayList.length;
                return displayList[this.currentHistoryIndex];
            },
            
            // å¯¼èˆªåˆ°ä¸‹ä¸€ä¸ªå†å²è®°å½•
            getNextHistory: function() {
                const displayList = this.getAllDisplayHistories();
                if (displayList.length === 0) return null;
                
                this.currentHistoryIndex = (this.currentHistoryIndex - 1 + displayList.length) % displayList.length;
                return displayList[this.currentHistoryIndex];
            },
            
            // é‡ç½®åˆ°ç¬¬ä¸€ä¸ªå†å²è®°å½•ï¼ˆå½“å‰æ¸¸æˆè®°å½•ï¼‰
            resetToFirst: function() {
                this.currentHistoryIndex = 0;
            },
            
            // è·å–å†å²è®°å½•æ•°é‡
            getHistoryCount: function() {
                const displayList = this.getAllDisplayHistories();
                return displayList.length;
            },
            
            // æ¸…ç©ºå½“å‰æ¸¸æˆå†å²è®°å½•
            clearCurrentGameHistory: function() {
                this.currentGameHistory = null;
            }
        };
        
        // è®¡åˆ†è§„åˆ™ - åŒ…å«7å 500åˆ†ï¼Œå…±10ä¸ªè®¡åˆ†ç»„
        const scoringRules = [
            { type: 'same', count: 2, name: '2å ', score: 10, icon: 'fas fa-layer-group' },
            { type: 'sequence', count: 3, name: '3è¿', score: 20, icon: 'fas fa-stream' },
            { type: 'same', count: 3, name: '3å ', score: 40, icon: 'fas fa-layer-group' },
            { type: 'sequence', count: 4, name: '4è¿', score: 60, icon: 'fas fa-stream' },
            { type: 'same', count: 4, name: '4å ', score: 80, icon: 'fas fa-layer-group' },
            { type: 'sequence', count: 5, name: '5è¿', score: 100, icon: 'fas fa-stream' },
            { type: 'sequence', count: 6, name: '6è¿', score: 140, icon: 'fas fa-stream' },
            { type: 'same', count: 5, name: '5å ', score: 180, icon: 'fas fa-layer-group' },
            { type: 'same', count: 6, name: '6å ', score: 320, icon: 'fas fa-layer-group' },
            { type: 'same', count: 7, name: '7å ', score: 500, icon: 'fas fa-layer-group' }
        ];
        
        // æŒ‰åˆ†æ•°ä»å°åˆ°å¤§æ’åº
        scoringRules.sort((a, b) => a.score - b.score);
        
        // æ ¹æ®ç»„åˆç±»å‹å’Œæ•°é‡è®¡ç®—åˆ†æ•°
        function calculateScore(type, count) {
            const rule = scoringRules.find(r => r.type === type && r.count === count);
            return rule ? rule.score : 0;
        }
        
        // DOMå…ƒç´ ç¼“å­˜
        const elements = {
            playerScore: document.querySelector('.player-score'),
            aiScore: document.querySelector('.ai-score'),
            playerRoundScore: document.getElementById('player-round-score-left'),
            aiRoundScore: document.getElementById('ai-round-score-left'),
            targetScore: document.getElementById('target-score'),
            roundNumber: document.getElementById('round-number'),
            turnIndicatorText: document.getElementById('turn-indicator-text'),
            diceContainer: document.getElementById('dice-container'),
            confirmContinueBtn: document.getElementById('confirm-continue-btn'),
            confirmEndBtn: document.getElementById('confirm-end-btn'),
            gameOverElement: document.getElementById('game-over'),
            winnerMessage: document.getElementById('winner-message'),
            winnerText: document.getElementById('winner-text'),
            finalPlayerScore: document.getElementById('final-player-score'),
            finalAiScore: document.getElementById('final-ai-score'),
            restartBtn: document.getElementById('restart-btn'),
            penaltyPopup: document.getElementById('penalty-popup'),
            penaltyMessage: document.getElementById('penalty-message'),
            penaltyScore: document.getElementById('penalty-score'),
            playerCard: document.getElementById('player-card'),
            aiCard: document.getElementById('ai-card'),
            historyBody: document.getElementById('history-body'),
            historyButton: document.getElementById('history-button'),
            totalRoundsDisplay: document.getElementById('total-rounds-display'),
            playerAvgScore: document.getElementById('player-avg-score'),
            playerMaxScore: document.getElementById('player-max-score'),
            aiAvgScore: document.getElementById('ai-avg-score'),
            aiMaxScore: document.getElementById('ai-max-score'),
            rulesButton: document.getElementById('rules-button'),
            rulesOverlay: document.getElementById('rules-overlay'),
            historyOverlay: document.getElementById('history-overlay'),
            gameOverHistoryBtn: document.getElementById('game-over-history-btn'),
            roundInfoBar: document.getElementById('round-info-bar'),
            rulesModalContent: document.getElementById('rules-modal-content'),
            historyModalContent: document.getElementById('history-modal-content'),
            playerFullClear: document.getElementById('player-full-clear'),
            aiFullClear: document.getElementById('ai-full-clear'),
            scoreTableGrid: document.getElementById('score-table-grid'),
            // æ–°å¢å†å²è®°å½•ç›¸å…³å…ƒç´ 
            historyTimeDisplay: document.getElementById('history-time-display'),
            historyLeftBtn: document.getElementById('history-left-btn'),
            historyRightBtn: document.getElementById('history-right-btn')
        };
        
        // è®¡åˆ†è¡¨é¡¹çŠ¶æ€
        let scoreTableItems = [];
        
        // åˆå§‹åŒ–è®¡åˆ†è¡¨
        function initScoreTable() {
            elements.scoreTableGrid.innerHTML = '';
            scoreTableItems = [];
            
            // æ·»åŠ è®¡åˆ†è¡¨é¡¹ - æ¨ªå‘å¸ƒå±€ï¼šå›¾æ ‡ åç§° åˆ†æ•°
            scoringRules.forEach(rule => {
                const item = document.createElement('div');
                item.className = 'score-table-item';
                item.dataset.type = rule.type;
                item.dataset.count = rule.count;
                item.innerHTML = `
                    <div class="score-table-icon ${rule.type}">
                        <i class="${rule.icon}"></i>
                    </div>
                    <div class="score-table-name">${rule.name}</div>
                    <div class="score-table-points">${rule.score}</div>
                `;
                
                elements.scoreTableGrid.appendChild(item);
                scoreTableItems.push({
                    element: item,
                    type: rule.type,
                    count: rule.count,
                    baseScore: rule.score,
                    name: rule.name,
                    badge: null // è§’æ ‡å…ƒç´ 
                });
            });
        }
        
        // æ›´æ–°è®¡åˆ†è¡¨é«˜äº®å’Œè§’æ ‡
        function updateScoreTableHighlight() {
            // é‡ç½®æ‰€æœ‰é¡¹
            scoreTableItems.forEach(item => {
                item.element.classList.remove('active', 'ai-active');
                // ç§»é™¤è§’æ ‡
                if (item.badge) {
                    item.badge.remove();
                    item.badge = null;
                }
                // é‡ç½®åˆ†æ•°æ˜¾ç¤ºä¸ºåŸºæœ¬åˆ†æ•°
                item.element.querySelector('.score-table-points').textContent = item.baseScore;
            });
            
            // å¦‚æœæ²¡æœ‰ç»„åˆï¼Œä¸è¿›è¡Œé«˜äº®
            if (gameState.currentCombination.length === 0) return;
            
            // ç»Ÿè®¡ç»„åˆç±»å‹å’Œæ•°é‡
            const combinationCounts = {};
            gameState.currentCombination.forEach(comb => {
                const key = `${comb.type}-${comb.type === 'sequence' ? comb.values.length : comb.count}`;
                if (!combinationCounts[key]) {
                    combinationCounts[key] = {
                        type: comb.type,
                        count: comb.type === 'sequence' ? comb.values.length : comb.count,
                        multiplier: 1
                    };
                } else {
                    // å¢åŠ å€æ•°ï¼ˆä»…é€‚ç”¨äº2å ã€3è¿å’Œ3å ï¼‰
                    if ((comb.type === 'same' && comb.count === 2) || 
                        (comb.type === 'sequence' && comb.values.length === 3) ||
                        (comb.type === 'same' && comb.count === 3)) {
                        combinationCounts[key].multiplier++;
                    }
                }
            });
            
            // é«˜äº®å¯¹åº”çš„è®¡åˆ†è¡¨é¡¹
            Object.values(combinationCounts).forEach(combInfo => {
                const item = scoreTableItems.find(item => 
                    item.type === combInfo.type && item.count === combInfo.count
                );
                
                if (item) {
                    // åº”ç”¨é«˜äº®
                    item.element.classList.add(gameState.currentPlayer === 'player' ? 'active' : 'ai-active');
                    
                    // å¦‚æœå€æ•°å¤§äº1ï¼Œæ·»åŠ è§’æ ‡ï¼ˆä½†ä¸ä¿®æ”¹åˆ†æ•°æ˜¾ç¤ºï¼‰
                    if (combInfo.multiplier > 1) {
                        // åˆ›å»ºè§’æ ‡
                        const badge = document.createElement('div');
                        badge.className = 'score-table-badge';
                        badge.textContent = combInfo.multiplier;
                        item.element.appendChild(badge);
                        item.badge = badge;
                        
                        // æ³¨æ„ï¼šä¸ä¿®æ”¹åˆ†æ•°æ˜¾ç¤ºï¼Œåªæ˜¾ç¤ºè§’æ ‡
                        // è®¡åˆ†è¡¨å†…çš„åˆ†æ•°ä¿æŒåŸºæœ¬åˆ†æ•°ä¸å˜
                    }
                }
            });
        }
        
        // éŸ³æ•ˆç³»ç»Ÿ
        let audioContext;
        
        // åˆå§‹åŒ–éŸ³æ•ˆç³»ç»Ÿ
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                gameState.audioInitialized = true;
            }
        }
        
        // æ’­æ”¾éŸ³æ•ˆ
        function playSound(type) {
            if (!gameState.audioInitialized) return;
            
            try {
                if (audioContext.state === 'suspended') audioContext.resume();
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                const tones = {
                    diceRoll: [200, 50],
                    diceSelect: [800, 400],
                    buttonClick: [600],
                    score: [523.25, 659.25, 783.99],
                    penalty: [200, 150, 100],
                    win: [523.25, 659.25, 783.99, 1046.50],
                    lose: [261.63, 220.00, 196.00, 174.61]
                };
                
                const currentTime = audioContext.currentTime;
                const typeData = tones[type];
                
                if (type === 'score' || type === 'penalty' || type === 'win' || type === 'lose') {
                    // å¤šéŸ³è°ƒéŸ³æ•ˆ
                    typeData.forEach((freq, index) => {
                        oscillator.frequency.setValueAtTime(freq, currentTime + index * 0.1);
                        gainNode.gain.setValueAtTime(0.3, currentTime + index * 0.1);
                    });
                    gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.5);
                    oscillator.start();
                    oscillator.stop(currentTime + 0.5);
                } else {
                    // å•éŸ³è°ƒéŸ³æ•ˆ
                    oscillator.frequency.setValueAtTime(typeData[0], currentTime);
                    if (typeData[1]) oscillator.frequency.exponentialRampToValueAtTime(typeData[1], currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.2, currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + (type === 'diceRoll' ? 0.5 : 0.1));
                    oscillator.start();
                    oscillator.stop(currentTime + (type === 'diceRoll' ? 0.5 : 0.1));
                }
            } catch (e) {
                console.log("éŸ³æ•ˆæ’­æ”¾å¤±è´¥:", e);
            }
        }
        
        // å¼¹çª—æ§åˆ¶
        elements.rulesButton.addEventListener('click', () => {
            elements.rulesOverlay.style.display = 'flex';
            document.getElementById('rules-close-hint').style.display = 'block';
            playSound('buttonClick');
        });
        
        elements.historyButton.addEventListener('click', () => {
            openHistoryModal();
            playSound('buttonClick');
        });
        
        elements.gameOverHistoryBtn.addEventListener('click', () => {
            openHistoryModal();
            playSound('buttonClick');
        });
        
        // ç‚¹å‡»é®ç½©å±‚å…³é—­å¼¹çª—
        elements.rulesOverlay.addEventListener('click', (e) => {
            if (e.target === elements.rulesOverlay) {
                elements.rulesOverlay.style.display = 'none';
            document.getElementById('rules-close-hint').style.display = 'none';
                document.getElementById('rules-close-hint').style.display = 'none';
                playSound('buttonClick');
            }
        });
        
        elements.historyOverlay.addEventListener('click', (e) => {
            if (e.target === elements.historyOverlay) {
                elements.historyOverlay.style.display = 'none';
            document.getElementById('history-close-hint').style.display = 'none';
                document.getElementById('history-close-hint').style.display = 'none';
                playSound('buttonClick');
            }
        });
        
        // é˜»æ­¢å¼¹çª—å†…å®¹ç‚¹å‡»äº‹ä»¶å†’æ³¡
        elements.rulesModalContent.addEventListener('click', (e) => e.stopPropagation());
        elements.historyModalContent.addEventListener('click', (e) => e.stopPropagation());
        
        // åˆ›å»ºéª°å­ç‚¹æ•°æ˜¾ç¤º
        function createDicePoints(value) {
            if (value === '?') return '<div class="dice-question">?</div>';
            
            const numValue = parseInt(value);
            let dotsHtml = '';
            for (let i = 0; i < numValue; i++) dotsHtml += '<div class="dot"></div>';
            for (let i = numValue; i < 6; i++) dotsHtml += '<div class="dot" style="opacity: 0;"></div>';
            
            return `<div class="dice-points dice-${numValue}">${dotsHtml}</div>`;
        }
        
        // æ›´æ–°å›åˆä¿¡æ¯æ æ ·å¼
        function updateRoundInfoBar() {
            if (gameState.currentPlayer === 'player') {
                elements.roundInfoBar.className = 'round-info-bar player-turn-round';
                elements.turnIndicatorText.innerHTML = '<i class="fas fa-user"></i> ç©å®¶å›åˆ';
            } else {
                elements.roundInfoBar.className = 'round-info-bar ai-turn-round';
                elements.turnIndicatorText.innerHTML = '<i class="fas fa-robot"></i> AIå›åˆ';
            }
            elements.roundNumber.textContent = gameState.currentRound;
        }
        
        // æ›´æ–°å›åˆé«˜äº®æ˜¾ç¤º
        function updateTurnHighlight() {
            if (gameState.currentPlayer === 'player') {
                elements.playerCard.classList.add('active-turn');
                elements.aiCard.classList.remove('active-turn');
            } else {
                elements.aiCard.classList.add('active-turn');
                elements.playerCard.classList.remove('active-turn');
            }
        }
        
        // æ·»åŠ ç§»åŠ¨ç«¯è§¦æ‘¸äº‹ä»¶æ”¯æŒ
        // åˆå§‹åŒ–æŒ‰é’®åŠ¨æ•ˆæ”¯æŒ
        function initButtonEffects() {
            const controlBtns = [elements.confirmContinueBtn, elements.confirmEndBtn];
            
            // é‡ç½®å¹¶æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
            controlBtns.forEach(btn => {
                if (!btn) return;
                
                // ç§»é™¤æ‰€æœ‰ç°æœ‰äº‹ä»¶ç›‘å¬å™¨
                btn.removeEventListener('touchstart', handleTouchStart);
                btn.removeEventListener('touchend', handleTouchEnd);
                btn.removeEventListener('touchcancel', handleTouchCancel);
                btn.removeEventListener('touchmove', handleTouchMove);
                btn.removeEventListener('click', handleClick);
                
                // æ·»åŠ è§¦æ‘¸äº‹ä»¶ç›‘å¬å™¨
                btn.addEventListener('touchstart', handleTouchStart, { passive: true });
                btn.addEventListener('touchend', handleTouchEnd, { passive: true });
                btn.addEventListener('touchcancel', handleTouchCancel, { passive: true });
                btn.addEventListener('touchmove', handleTouchMove, { passive: true });
                
                // æ·»åŠ ç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨ï¼ˆé’ˆå¯¹æ¡Œé¢ç«¯ï¼‰
                btn.addEventListener('click', handleClick);
            });
        }
        
        // è§¦æ‘¸å¼€å§‹äº‹ä»¶å¤„ç†å‡½æ•°
        function handleTouchStart(e) {
            const btn = e.currentTarget;
            if (btn.disabled) return;
            
            btn.classList.add('touch-active');
        }
        
        // è§¦æ‘¸ç»“æŸäº‹ä»¶å¤„ç†å‡½æ•°
        function handleTouchEnd(e) {
            e.preventDefault(); // é˜»æ­¢é»˜è®¤è§¦æ‘¸è¡Œä¸ºï¼Œé˜²æ­¢è§¦å‘åç»­çš„clickäº‹ä»¶
            const btn = e.currentTarget;
            if (btn.disabled) return;
            
            // ç«‹å³è§¦å‘æŒ‰é’®åŠŸèƒ½ï¼Œä½†ç¡®ä¿åŠ¨ç”»ä¸å—å½±å“
            setTimeout(() => {
                if (btn.id === 'confirm-continue-btn') {
                    confirmAndContinue();
                } else if (btn.id === 'confirm-end-btn') {
                    confirmAndEnd();
                }
            }, 0); // åœ¨ä¸‹ä¸€ä¸ªäº‹ä»¶å¾ªç¯ä¸­æ‰§è¡Œï¼Œä¸å½±å“åŠ¨ç”»
            
            // å»¶è¿Ÿç§»é™¤è§¦æ‘¸æ¿€æ´»ç±»ï¼Œç¡®ä¿åŠ¨ç”»æœ‰è¶³å¤Ÿæ—¶é—´æ˜¾ç¤º
            setTimeout(() => {
                btn.classList.remove('touch-active');
            }, 100); // å›ºå®š100msçš„åŠ¨ç”»æ—¶é—´ï¼Œä¸æŒ‰é’®åŠŸèƒ½æ‰§è¡Œæ—¶é—´æ— å…³
        }
        
        // è§¦æ‘¸å–æ¶ˆäº‹ä»¶å¤„ç†å‡½æ•°
        function handleTouchCancel(e) {
            const btn = e.currentTarget;
            btn.classList.remove('touch-active');
        }
        
        // è§¦æ‘¸ç§»åŠ¨äº‹ä»¶å¤„ç†å‡½æ•°
        function handleTouchMove(e) {
            const btn = e.currentTarget;
            btn.classList.remove('touch-active');
        }
        
        // ç‚¹å‡»äº‹ä»¶å¤„ç†å‡½æ•°ï¼ˆæ¡Œé¢ç«¯ï¼‰
        function handleClick(e) {
            const btn = e.currentTarget;
            if (btn.disabled) return;
            
            // å¯¹äºç‚¹å‡»äº‹ä»¶ï¼ŒCSSçš„:activeä¼ªç±»ä¼šå¤„ç†åŠ¨æ•ˆï¼Œä¸éœ€è¦é¢å¤–æ·»åŠ ç±»
        }
        
        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            Object.assign(gameState, {
                playerScore: 0,
                aiScore: 0,
                targetScore: 700,
                currentPlayer: 'player',
                diceValues: [],
                selectedDice: [],
                currentSequence: [],
                roundScore: 0,
                gameActive: true,
                roundActive: false,
                diceCount: 7,
                canSelectNewSequence: true,
                currentCombination: [],
                currentRound: 1,
                playerRoundScore: 0,
                aiRoundScore: 0,
                roundCompleted: false,
                gameHistory: [],
                currentPlayerCombinationString: '',
                currentAICombinationString: '',
                playerPenaltyThisRound: false,
                aiPenaltyThisRound: false,
                audioInitialized: gameState.audioInitialized,
                playerFullClearCount: 0,
                aiFullClearCount: 0,
                buttonCooldown: false
            });
            
            // åŠ è½½å†å²è®°å½•
            historyManager.loadHistory();
            
            // æ¸…ç©ºå½“å‰æ¸¸æˆå†å²è®°å½•
            historyManager.clearCurrentGameHistory();
            
            updateScores();
            updateRoundScoreDisplay();
            updateRoundInfoBar();
            updateTurnHighlight();
            createDiceElements();
            updateScoreTableHighlight();
            
            disableAllButtons();
            elements.gameOverElement.style.display = 'none';
            elements.penaltyPopup.style.display = 'none';
            elements.rulesOverlay.style.display = 'none';
            elements.historyOverlay.style.display = 'none';
            
            initScoreTable();
            if (!gameState.audioInitialized) initAudio();
            
            // åˆå§‹åŒ–æŒ‰é’®åŠ¨æ•ˆæ”¯æŒ
            initButtonEffects();
            
            setTimeout(() => rollDice(), 1000);
        }
        
        // åˆ›å»ºéª°å­å…ƒç´ 
        function createDiceElements() {
            elements.diceContainer.innerHTML = '';
            
            for (let i = 0; i < gameState.diceCount; i++) {
                const diceWrapper = document.createElement('div');
                diceWrapper.className = 'dice-wrapper';
                
                const dice = document.createElement('div');
                dice.className = 'dice';
                dice.dataset.index = i;
                dice.dataset.value = gameState.diceValues[i] || '?';
                
                dice.innerHTML = createDicePoints(gameState.diceValues[i] || '?');
                
                if (gameState.diceValues[i] && gameState.diceValues[i] !== '?') {
                    dice.classList.remove('used', 'locked', 'selected', 'ai-selected');
                    if (gameState.selectedDice.includes(i)) dice.classList.add('used');
                    if (gameState.currentSequence.includes(i)) {
                        dice.classList.add(gameState.currentPlayer === 'player' ? 'selected' : 'ai-selected');
                    }
                    if (!gameState.canSelectNewSequence && !gameState.selectedDice.includes(i) && !gameState.currentSequence.includes(i)) dice.classList.add('locked');
                } else {
                    // é—®å·éª°å­ç¡®ä¿ä¸è¢«å…¶ä»–ç±»è¦†ç›–æ ·å¼
                    dice.classList.remove('used', 'locked', 'selected', 'ai-selected');
                    if (gameState.selectedDice.includes(i)) {
                        dice.classList.add('used');
                        // ç¡®ä¿é—®å·éª°å­çš„èƒŒæ™¯è‰²ä¸ä¼šè¢«usedç±»è¦†ç›–
                        dice.style.backgroundColor = '#fff';
                        dice.style.color = '#666';
                    }
                }
                
                diceWrapper.appendChild(dice);
                
                if (gameState.currentPlayer === 'player') {
                    dice.addEventListener('click', () => selectDice(i));
                    dice.style.cursor = 'pointer';
                } else {
                    dice.style.cursor = 'default';
                }
                elements.diceContainer.appendChild(diceWrapper);
            }
        }
        
        // æ›´æ–°éª°å­æ˜¾ç¤º - å…³é”®ä¿®æ”¹éƒ¨åˆ†
        function updateDiceDisplay() {
            document.querySelectorAll('.dice-wrapper').forEach((wrapper, index) => {
                const dice = wrapper.querySelector('.dice');
                dice.innerHTML = createDicePoints(gameState.diceValues[index] || '?');
                dice.dataset.value = gameState.diceValues[index] || '?';
                
                // æ¸…é™¤æ‰€æœ‰å¯èƒ½å½±å“æ ·å¼çš„ç±»
                dice.classList.remove('selected', 'ai-selected', 'used', 'locked');
                
                // å¦‚æœéª°å­æ˜¯é—®å·ï¼Œç¡®ä¿å®ƒçš„æ ·å¼ä¼˜å…ˆçº§æœ€é«˜
                if (gameState.diceValues[index] === '?') {
                    // å¼ºåˆ¶è®¾ç½®å†…è”æ ·å¼ï¼Œç¡®ä¿é—®å·éª°å­æ˜¯ç™½è‰²
                    dice.style.backgroundColor = '#fff';
                    dice.style.color = '#666';
                    dice.style.opacity = '1';
                    
                    // ä»ç„¶æ·»åŠ çŠ¶æ€ç±»ï¼Œä½†æ ·å¼ä¼šè¢«CSSè¦†ç›–
                    if (gameState.selectedDice.includes(index)) {
                        dice.classList.add('used');
                    } else if (gameState.currentSequence.includes(index)) {
                        dice.classList.add(gameState.currentPlayer === 'player' ? 'selected' : 'ai-selected');
                    } else if (!gameState.canSelectNewSequence && !gameState.selectedDice.includes(index)) {
                        dice.classList.add('locked');
                    }
                } else {
                    // æ™®é€šéª°å­æŒ‰æ­£å¸¸é€»è¾‘å¤„ç†
                    dice.style.backgroundColor = '';
                    dice.style.color = '';
                    dice.style.opacity = '';
                    
                    if (gameState.selectedDice.includes(index)) dice.classList.add('used');
                    else if (gameState.currentSequence.includes(index)) {
                        dice.classList.add(gameState.currentPlayer === 'player' ? 'selected' : 'ai-selected');
                    } else if (!gameState.canSelectNewSequence && !gameState.selectedDice.includes(index)) dice.classList.add('locked');
                }
            });
        }
        
        // æŠ•æ·éª°å­åŠ¨ç”»æ•ˆæœ
        function animateDiceRoll() {
            document.querySelectorAll('.dice').forEach((dice, index) => {
                if (!gameState.selectedDice.includes(index)) {
                    dice.classList.add('shaking');
                    setTimeout(() => dice.classList.remove('shaking'), 500);
                }
            });
        }
        
        // æŠ•æ·éª°å­
        function rollDice() {
            if (!gameState.gameActive) return;
            
            animateDiceRoll();
            playSound('diceRoll');
            
            if (gameState.roundActive) {
                // æ™®é€šé‡æŠ•ï¼šåªé‡æŠ•é—®å·éª°å­ï¼ˆå³æœªé€‰æ‹©çš„éª°å­ï¼‰
                for (let i = 0; i < gameState.diceCount; i++) {
                    if (!gameState.selectedDice.includes(i) && gameState.diceValues[i] === '?') {
                        gameState.diceValues[i] = Math.floor(Math.random() * 6) + 1;
                    }
                }
            } else {
                // æ–°å›åˆå¼€å§‹ï¼Œé‡ç½®æ‰€æœ‰éª°å­
                gameState.diceValues = [];
                gameState.selectedDice = [];
                gameState.currentSequence = [];
                for (let i = 0; i < gameState.diceCount; i++) {
                    gameState.diceValues.push(Math.floor(Math.random() * 6) + 1);
                }
            }
            
            gameState.canSelectNewSequence = true;
            
            setTimeout(() => {
                createDiceElements();
                
                const hasValidCombination = checkForValidCombinations();
                
                if (!hasValidCombination) {
                    if (gameState.roundActive) {
                        showPenaltyPopup(gameState.roundScore);
                        
                        if (gameState.currentPlayer === 'player') {
                            gameState.playerPenaltyThisRound = true;
                            gameState.currentPlayerCombinationString = 'æƒ©ç½šå½’é›¶';
                        } else {
                            gameState.aiPenaltyThisRound = true;
                            gameState.currentAICombinationString = 'æƒ©ç½šå½’é›¶';
                        }
                        
                        gameState.roundScore = 0;
                        updateRoundScoreDisplay();
                        
                        setTimeout(() => {
                            endRound();
                        }, 2000);
                    } else {
                        setTimeout(() => {
                            if (gameState.currentPlayer === 'player') {
                                gameState.currentPlayerCombinationString = 'æ— æœ‰æ•ˆç»„åˆ';
                            } else {
                                gameState.currentAICombinationString = 'æ— æœ‰æ•ˆç»„åˆ';
                            }
                            endRound();
                        }, 1500);
                    }
                } else {
                    if (gameState.currentPlayer === 'player') {
                        const remainingDiceCount = gameState.diceCount - gameState.selectedDice.length;
                        
                        if (remainingDiceCount === 1) {
                            elements.confirmContinueBtn.disabled = true;
                            elements.confirmEndBtn.disabled = false;
                        } else {
                            elements.confirmContinueBtn.disabled = true;
                            elements.confirmEndBtn.disabled = true;
                        }
                    } else {
                        setTimeout(aiSelectCombination, 1000);
                    }
                }
            }, 500);
        }
        
        // æ˜¾ç¤ºæƒ©ç½šå¼¹çª—
        function showPenaltyPopup(lostScore) {
            elements.penaltyMessage.textContent = 'æœ¬å›åˆåˆ†æ•°ä½œåºŸ';
            elements.penaltyScore.textContent = `æŸå¤±åˆ†æ•°: ${lostScore}`;
            elements.penaltyPopup.style.display = 'block';
            playSound('penalty');
            
            setTimeout(() => {
                elements.penaltyPopup.style.display = 'none';
            }, 2000);
        }
        
        // æ ¹æ®é€‰æ‹©é¡ºåºåˆ†æç»„åˆ
        function analyzeCombinationByOrder() {
            if (gameState.currentSequence.length === 0) return [];
            
            const orderedValues = gameState.currentSequence.map(i => gameState.diceValues[i]);
            const groups = [];
            let currentGroup = [];
            
            for (let i = 0; i < orderedValues.length; i++) {
                if (currentGroup.length === 0) {
                    currentGroup.push({index: gameState.currentSequence[i], value: orderedValues[i]});
                } else {
                    const lastValue = currentGroup[currentGroup.length - 1].value;
                    const currentValue = orderedValues[i];
                    const isConsecutive = currentValue === lastValue + 1;
                    const isSame = currentValue === lastValue;
                    
                    if (currentGroup.length === 1) {
                        if (isConsecutive || isSame) {
                            currentGroup.push({index: gameState.currentSequence[i], value: currentValue});
                        } else {
                            groups.push([...currentGroup]);
                            currentGroup = [{index: gameState.currentSequence[i], value: currentValue}];
                        }
                    } else {
                        const firstValue = currentGroup[0].value;
                        const secondValue = currentGroup[1].value;
                        const isSequenceGroup = secondValue === firstValue + 1;
                        const isSameGroup = secondValue === firstValue;
                        
                        if ((isSequenceGroup && isConsecutive) || (isSameGroup && isSame)) {
                            currentGroup.push({index: gameState.currentSequence[i], value: currentValue});
                        } else {
                            groups.push([...currentGroup]);
                            currentGroup = [{index: gameState.currentSequence[i], value: currentValue}];
                        }
                    }
                }
            }
            
            if (currentGroup.length > 0) groups.push([...currentGroup]);
            
            const combination = [];
            let isValid = true;
            
            for (const group of groups) {
                if (group.length < 2) { isValid = false; break; }
                
                const values = group.map(g => g.value);
                const firstValue = values[0];
                const secondValue = values[1];
                
                if (secondValue === firstValue + 1) {
                    let isConsecutive = true;
                    for (let i = 1; i < values.length; i++) {
                        if (values[i] !== values[i-1] + 1) { isConsecutive = false; break; }
                    }
                    
                    if (isConsecutive && values.length >= 3) {
                        combination.push({
                            type: 'sequence',
                            values: values,
                            score: calculateScore('sequence', values.length),
                            indices: group.map(g => g.index)
                        });
                    } else { isValid = false; break; }
                } else if (secondValue === firstValue) {
                    let allSame = true;
                    for (let i = 1; i < values.length; i++) {
                        if (values[i] !== firstValue) { allSame = false; break; }
                    }
                    
                    if (allSame && values.length >= 2) {
                        combination.push({
                            type: 'same',
                            value: firstValue,
                            count: values.length,
                            score: calculateScore('same', values.length),
                            indices: group.map(g => g.index)
                        });
                    } else { isValid = false; break; }
                } else { isValid = false; break; }
            }
            
            return isValid ? combination : [];
        }
        
        // ç”Ÿæˆç»„åˆå­—ç¬¦ä¸²
        function generateCombinationString(combination) {
            if (!combination || combination.length === 0) return '';
            
            return combination.map(item => {
                if (item.type === 'sequence') {
                    return item.values.join(',');
                } else {
                    return Array(item.count).fill(item.value).join(',');
                }
            }).join(' + ');
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨ç»„åˆå¯é€‰
        function checkForValidCombinations() {
            const availableDice = [];
            for (let i = 0; i < gameState.diceCount; i++) {
                if (!gameState.selectedDice.includes(i)) {
                    availableDice.push({index: i, value: gameState.diceValues[i]});
                }
            }
            
            const valueCounts = {};
            availableDice.forEach(dice => valueCounts[dice.value] = (valueCounts[dice.value] || 0) + 1);
            
            for (const value in valueCounts) if (valueCounts[value] >= 2) return true;
            
            const uniqueValues = [...new Set(availableDice.map(d => d.value))].sort((a, b) => a - b);
            let consecutiveCount = 1;
            for (let i = 1; i < uniqueValues.length; i++) {
                if (uniqueValues[i] === uniqueValues[i-1] + 1) {
                    consecutiveCount++;
                    if (consecutiveCount >= 3) return true;
                } else consecutiveCount = 1;
            }
            
            return false;
        }
        
        // é€‰æ‹©éª°å­
        function selectDice(index) {
            if (!gameState.gameActive || gameState.currentPlayer !== 'player' || 
                gameState.selectedDice.includes(index) || !gameState.canSelectNewSequence) return;
            
            playSound('diceSelect');
            
            if (gameState.currentSequence.includes(index)) {
                const position = gameState.currentSequence.indexOf(index);
                gameState.currentSequence.splice(position, 1);
                updateDiceDisplay();
                gameState.currentCombination = analyzeCombinationByOrder();
                updateScoreTableHighlight();
                updateButtonState();
                return;
            }
            
            gameState.currentSequence.push(index);
            updateDiceDisplay();
            gameState.currentCombination = analyzeCombinationByOrder();
            updateScoreTableHighlight();
            updateButtonState();
        }
        
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        function updateButtonState() {
            if (gameState.currentCombination.length === 0) {
                elements.confirmContinueBtn.disabled = true;
                elements.confirmEndBtn.disabled = true;
            } else {
                const selectedCountInCurrentCombination = gameState.currentCombination.reduce((sum, item) => sum + item.indices.length, 0);
                const remainingDiceCount = gameState.diceCount - gameState.selectedDice.length - selectedCountInCurrentCombination;
                
                if (remainingDiceCount === 1) {
                    elements.confirmContinueBtn.disabled = true;
                    elements.confirmEndBtn.disabled = false;
                } else if (remainingDiceCount === 0) {
                    elements.confirmContinueBtn.disabled = false;
                    elements.confirmEndBtn.disabled = false;
                } else {
                    elements.confirmContinueBtn.disabled = false;
                    elements.confirmEndBtn.disabled = false;
                }
            }
        }
        
        // è®¡åˆ†å¹¶å†æ¬¡æŠ•æ· - ä¿®å¤è®¡åˆ†é€»è¾‘
        function confirmAndContinue() {
            if (gameState.buttonCooldown) return;
            gameState.buttonCooldown = true;
            playSound('buttonClick');
            if (gameState.currentCombination.length === 0) {
                gameState.buttonCooldown = false;
                return;
            }
            
            // ä¿®å¤è®¡åˆ†é€»è¾‘ï¼šç»Ÿè®¡æ¯ç§ç»„åˆçš„æ•°é‡ï¼Œç„¶åè®¡ç®—æ€»åˆ†
            const combinationCounts = {};
            gameState.currentCombination.forEach(comb => {
                const key = `${comb.type}-${comb.type === 'sequence' ? comb.values.length : comb.count}`;
                if (!combinationCounts[key]) {
                    combinationCounts[key] = {
                        type: comb.type,
                        count: comb.type === 'sequence' ? comb.values.length : comb.count,
                        multiplier: 1,
                        baseScore: comb.score // å­˜å‚¨åŸºç¡€åˆ†æ•°
                    };
                } else {
                    // å¢åŠ å€æ•°ï¼ˆä»…é€‚ç”¨äº2å ã€3è¿å’Œ3å ï¼‰
                    if ((comb.type === 'same' && comb.count === 2) || 
                        (comb.type === 'sequence' && comb.values.length === 3) ||
                        (comb.type === 'same' && comb.count === 3)) {
                        combinationCounts[key].multiplier++;
                    }
                }
            });
            
            // è®¡ç®—æ€»åˆ†ï¼šæ¯ä¸ªç»„åˆçš„åŸºç¡€åˆ†æ•° Ã— æ•°é‡
            let totalScore = 0;
            Object.values(combinationCounts).forEach(combInfo => {
                totalScore += combInfo.baseScore * combInfo.multiplier;
            });
            
            const allIndices = gameState.currentCombination.flatMap(item => item.indices);
            
            const uniqueIndices = [...new Set(allIndices)];
            if (uniqueIndices.length !== allIndices.length) return;
            
            gameState.selectedDice.push(...allIndices);
            gameState.roundScore += totalScore;
            
            if (gameState.currentPlayer === 'player') {
                gameState.playerRoundScore = gameState.roundScore;
                const currentCombinationString = generateCombinationString(gameState.currentCombination);
                if (gameState.currentPlayerCombinationString && gameState.currentPlayerCombinationString !== 'æƒ©ç½šå½’é›¶') {
                    gameState.currentPlayerCombinationString += ' + ' + currentCombinationString;
                } else gameState.currentPlayerCombinationString = currentCombinationString;
            } else {
                gameState.aiRoundScore = gameState.roundScore;
                const currentCombinationString = generateCombinationString(gameState.currentCombination);
                if (gameState.currentAICombinationString && gameState.currentAICombinationString !== 'æƒ©ç½šå½’é›¶') {
                    gameState.currentAICombinationString += ' + ' + currentCombinationString;
                } else gameState.currentAICombinationString = currentCombinationString;
            }
            
            gameState.currentSequence = [];
            gameState.currentCombination = [];
            
            // å»¶è¿Ÿç¦ç”¨æŒ‰é’®ï¼Œç¡®ä¿åŠ¨ç”»å®Œæˆ
            setTimeout(() => {
                // å¥–åŠ±é‡æŠ•é€»è¾‘ï¼ˆ7ä¸ªéª°å­å…¨éƒ¨è®¡åˆ†ï¼‰
                if (gameState.selectedDice.length === gameState.diceCount) {
                    if (gameState.currentPlayer === 'player') {
                        gameState.playerFullClearCount++;
                    } else {
                        gameState.aiFullClearCount++;
                    }
                    
                    // å…ˆè®©éª°å­æ˜¾ç¤ºä¸ºæ‰“å‡ºçŠ¶æ€ï¼ˆç¼©å°ã€ç°è‰²ã€å³ä¸Šè§’æœ‰çº¢å‰ï¼‰
                    gameState.canSelectNewSequence = false;
                    updateDiceDisplay();
                    updateScoreTableHighlight();
                    updateRoundScoreDisplay();
                    gameState.roundActive = true;
                    disableAllButtons();
                    
                    // å»¶è¿Ÿä¸€æ®µæ—¶é—´åï¼Œé‡ç½®éª°å­ä¸ºé—®å·çŠ¶æ€ï¼Œç„¶åé‡æŠ•
                    setTimeout(() => {
                        // é‡ç½®æ‰€æœ‰éª°å­å€¼ä¸ºé—®å·
                        for (let i = 0; i < gameState.diceCount; i++) {
                            gameState.diceValues[i] = '?';
                        }
                        
                        // æ¸…ç©ºå·²é€‰æ‹©çš„éª°å­ï¼Œå‡†å¤‡é‡æŠ•
                        gameState.selectedDice = [];
                        gameState.currentSequence = [];
                        gameState.currentCombination = [];
                        
                        // æ›´æ–°æ˜¾ç¤ºä¸ºé—®å·ï¼ˆç™½è‰²ï¼‰
                        updateDiceDisplay();
                        updateScoreTableHighlight();
                        
                        // å»¶è¿Ÿåé‡æŠ•éª°å­
                        setTimeout(() => {
                            rollDice();
                            gameState.buttonCooldown = false;
                        }, 500);
                    }, 1000);
                    return;
                }
                
                // æ™®é€šé‡æŠ•é€»è¾‘ï¼ˆä¸æ˜¯æ‰€æœ‰éª°å­éƒ½è¢«è®¡åˆ†ï¼‰
                gameState.canSelectNewSequence = false;
                updateDiceDisplay();
                updateScoreTableHighlight();
                updateRoundScoreDisplay();
                gameState.roundActive = true;
                disableAllButtons();
                
                // å°†å‰©ä½™çš„éª°å­ï¼ˆæ²¡æœ‰è¢«é€‰ä¸­çš„éª°å­ï¼‰è®¾ç½®ä¸ºé—®å·
                for (let i = 0; i < gameState.diceCount; i++) {
                    if (!gameState.selectedDice.includes(i)) {
                        gameState.diceValues[i] = '?';
                    }
                }
                
                // æ›´æ–°æ˜¾ç¤ºä¸ºé—®å·ï¼ˆç™½è‰²ï¼‰
                updateDiceDisplay();
                updateScoreTableHighlight();
                
                // å»¶è¿Ÿåé‡æŠ•éª°å­
                setTimeout(() => {
                    rollDice();
                    gameState.buttonCooldown = false;
                }, 1000);
            }, 100); // ä¸åŠ¨ç”»æ—¶é—´ç›¸åŒï¼Œç¡®ä¿åŠ¨ç”»å®Œæˆåå†è¿›è¡Œåç»­æ“ä½œ
        }
        
        // è®¡åˆ†å¹¶ç»“æŸå›åˆ - ä¿®å¤è®¡åˆ†é€»è¾‘
        function confirmAndEnd() {
            if (gameState.buttonCooldown) return;
            gameState.buttonCooldown = true;
            playSound('buttonClick');
            if (gameState.currentCombination.length === 0) {
                gameState.buttonCooldown = false;
                return;
            }
            
            // ä¿®å¤è®¡åˆ†é€»è¾‘ï¼šç»Ÿè®¡æ¯ç§ç»„åˆçš„æ•°é‡ï¼Œç„¶åè®¡ç®—æ€»åˆ†
            const combinationCounts = {};
            gameState.currentCombination.forEach(comb => {
                const key = `${comb.type}-${comb.type === 'sequence' ? comb.values.length : comb.count}`;
                if (!combinationCounts[key]) {
                    combinationCounts[key] = {
                        type: comb.type,
                        count: comb.type === 'sequence' ? comb.values.length : comb.count,
                        multiplier: 1,
                        baseScore: comb.score // å­˜å‚¨åŸºç¡€åˆ†æ•°
                    };
                } else {
                    // å¢åŠ å€æ•°ï¼ˆä»…é€‚ç”¨äº2å ã€3è¿å’Œ3å ï¼‰
                    if ((comb.type === 'same' && comb.count === 2) || 
                        (comb.type === 'sequence' && comb.values.length === 3) ||
                        (comb.type === 'same' && comb.count === 3)) {
                        combinationCounts[key].multiplier++;
                    }
                }
            });
            
            // è®¡ç®—æ€»åˆ†ï¼šæ¯ä¸ªç»„åˆçš„åŸºç¡€åˆ†æ•° Ã— æ•°é‡
            let totalScore = 0;
            Object.values(combinationCounts).forEach(combInfo => {
                totalScore += combInfo.baseScore * combInfo.multiplier;
            });
            
            const allIndices = gameState.currentCombination.flatMap(item => item.indices);
            
            const uniqueIndices = [...new Set(allIndices)];
            if (uniqueIndices.length !== allIndices.length) return;
            
            gameState.selectedDice.push(...allIndices);
            gameState.roundScore += totalScore;
            
            if (gameState.currentPlayer === 'player') {
                gameState.playerRoundScore = gameState.roundScore;
                const currentCombinationString = generateCombinationString(gameState.currentCombination);
                if (gameState.currentPlayerCombinationString && gameState.currentPlayerCombinationString !== 'æƒ©ç½šå½’é›¶') {
                    gameState.currentPlayerCombinationString += ' + ' + currentCombinationString;
                } else gameState.currentPlayerCombinationString = currentCombinationString;
            } else {
                gameState.aiRoundScore = gameState.roundScore;
                const currentCombinationString = generateCombinationString(gameState.currentCombination);
                if (gameState.currentAICombinationString && gameState.currentAICombinationString !== 'æƒ©ç½šå½’é›¶') {
                    gameState.currentAICombinationString += ' + ' + currentCombinationString;
                } else gameState.currentAICombinationString = currentCombinationString;
            }
            
            gameState.currentSequence = [];
            gameState.currentCombination = [];
            
            // å»¶è¿Ÿæ‰§è¡Œåç»­æ“ä½œï¼Œç¡®ä¿åŠ¨ç”»å®Œæˆ
            setTimeout(() => {
                updateDiceDisplay();
                updateScoreTableHighlight();
                updateRoundScoreDisplay();
                disableAllButtons(); // æ·»åŠ ç¦ç”¨æŒ‰é’®ï¼Œä¿æŒä¸confirmAndContinueä¸€è‡´
                setTimeout(() => {
                    endRound();
                    gameState.buttonCooldown = false;
                }, 1000);
            }, 100); // ä¸åŠ¨ç”»æ—¶é—´ç›¸åŒï¼Œç¡®ä¿åŠ¨ç”»å®Œæˆåå†è¿›è¡Œåç»­æ“ä½œ
        }
        
        // ç»“æŸæœ¬å›åˆå¹¶è®¡åˆ†
        function endRound() {
            if (!gameState.gameActive) return;
            
            if (gameState.currentPlayer === 'player') {
                gameState.playerScore += gameState.roundScore;
                if (gameState.playerScore >= gameState.targetScore) {
                    // æ¸¸æˆç»“æŸ
                }
            } else {
                gameState.aiScore += gameState.roundScore;
                if (gameState.aiScore >= gameState.targetScore) {
                    // æ¸¸æˆç»“æŸ
                }
            }
            
            updateScores();
            checkRoundEnd();
            if (!gameState.gameActive) return;
            
            if (gameState.currentPlayer === 'ai') {
                gameState.roundCompleted = true;
                updateRoundInfoBar();
                gameState.gameHistory.push({
                    round: gameState.currentRound,
                    playerScore: gameState.playerRoundScore,
                    playerCumulativeScore: gameState.playerScore,
                    aiScore: gameState.aiRoundScore,
                    aiCumulativeScore: gameState.aiScore,
                    playerCombination: gameState.currentPlayerCombinationString || 'æ— æœ‰æ•ˆç»„åˆ',
                    aiCombination: gameState.currentAICombinationString || 'æ— æœ‰æ•ˆç»„åˆ',
                    playerPenalty: gameState.playerPenaltyThisRound,
                    aiPenalty: gameState.aiPenaltyThisRound
                });
                
                setTimeout(() => {
                    gameState.roundScore = 0; gameState.roundActive = false; gameState.canSelectNewSequence = true;
                    gameState.currentSequence = []; gameState.currentCombination = []; gameState.selectedDice = [];
                    gameState.currentPlayerCombinationString = ''; gameState.currentAICombinationString = '';
                    gameState.playerPenaltyThisRound = false; gameState.aiPenaltyThisRound = false;
                    gameState.currentRound++; gameState.playerRoundScore = 0; gameState.aiRoundScore = 0; gameState.roundCompleted = false;
                    gameState.currentPlayer = 'player';
                    updateRoundInfoBar(); updateTurnHighlight(); updateRoundScoreDisplay();
                    disableAllButtons();
                    gameState.diceValues = new Array(gameState.diceCount).fill('?');
                    createDiceElements(); updateScoreTableHighlight();
                    setTimeout(() => rollDice(), 1000);
                }, 800);
            } else {
                gameState.roundScore = 0; gameState.roundActive = false; gameState.canSelectNewSequence = true;
                gameState.currentSequence = []; gameState.currentCombination = []; gameState.selectedDice = [];
                gameState.currentPlayer = 'ai';
                updateRoundInfoBar(); updateTurnHighlight(); updateRoundScoreDisplay();
                disableAllButtons();
                gameState.diceValues = new Array(gameState.diceCount).fill('?');
                createDiceElements(); updateScoreTableHighlight();
                setTimeout(() => rollDice(), 1500);
            }
        }
        
        // æ£€æŸ¥å›åˆç»“æŸæ¡ä»¶
        function checkRoundEnd() {
            if (!gameState.gameActive) return;
            if (gameState.currentPlayer === 'ai') {
                if (gameState.playerScore >= gameState.targetScore || gameState.aiScore >= gameState.targetScore) {
                    gameState.gameActive = false;
                    gameState.gameHistory.push({
                        round: gameState.currentRound,
                        playerScore: gameState.playerRoundScore,
                        playerCumulativeScore: gameState.playerScore,
                        aiScore: gameState.aiRoundScore,
                        aiCumulativeScore: gameState.aiScore,
                        playerCombination: gameState.currentPlayerCombinationString || 'æ— æœ‰æ•ˆç»„åˆ',
                        aiCombination: gameState.currentAICombinationString || 'æ— æœ‰æ•ˆç»„åˆ',
                        playerPenalty: gameState.playerPenaltyThisRound,
                        aiPenalty: gameState.aiPenaltyThisRound
                    });
                    
                    let winner;
                    let winnerText;
                    if (gameState.playerScore > gameState.aiScore) {
                        winner = 'player';
                        winnerText = 'ç©å®¶è·èƒœ';
                    } else if (gameState.aiScore > gameState.playerScore) {
                        winner = 'ai';
                        winnerText = 'AIè·èƒœ';
                    } else {
                        winner = 'tie';
                        winnerText = 'å¹³å±€';
                    }
                    endGame(winner, winnerText);
                }
            }
        }
        
        // ==================== ä¿®æ”¹åçš„AIç­–ç•¥ ====================
        
        // ä¸ºAIæ‰¾å‡ºæ‰€æœ‰å¯èƒ½çš„ä¸é‡å ç»„åˆ
        function findAllValidCombinationsForAI(availableDice) {
            if (availableDice.length < 2) return [];
            
            const diceCount = availableDice.length;
            const diceValues = availableDice.map(d => d.value);
            const diceIndices = availableDice.map(d => d.index);
            
            // æ‰€æœ‰å¯èƒ½çš„ç»„åˆé›†åˆ
            const allCombinationSets = [];
            
            // é€’å½’æœç´¢å‡½æ•°
            function searchCombinations(currentSet, usedIndices, currentScore, startIndex) {
                // ä¿å­˜å½“å‰ç»„åˆé›†åˆ
                if (currentSet.length > 0) {
                    allCombinationSets.push({
                        combinations: [...currentSet],
                        totalScore: currentScore,
                        totalDiceUsed: usedIndices.size
                    });
                }
                
                // å¦‚æœå·²ç»ç”¨å®Œæ‰€æœ‰éª°å­ï¼Œåœæ­¢æœç´¢
                if (usedIndices.size === diceCount) return;
                
                // å°è¯•æ‰€æœ‰å¯èƒ½çš„ç»„åˆ
                for (let i = startIndex; i < diceCount; i++) {
                    // è·³è¿‡å·²ä½¿ç”¨çš„éª°å­
                    if (usedIndices.has(diceIndices[i])) continue;
                    
                    // 1. å°è¯•è¿ç»­æ•°ç»„åˆ
                    // æŸ¥æ‰¾ä»å½“å‰éª°å­å¼€å§‹çš„è¿ç»­æ•°
                    for (let len = 3; len <= Math.min(6, diceCount - usedIndices.size); len++) {
                        // å¯èƒ½çš„è¿ç»­æ•°å€¼
                        const startValue = diceValues[i];
                        const sequence = [];
                        for (let j = 0; j < len; j++) sequence.push(startValue + j);
                        
                        // æ£€æŸ¥æ˜¯å¦èƒ½ç”¨å‰©ä½™éª°å­ç»„æˆè¿™ä¸ªåºåˆ—
                        const neededIndices = new Set();
                        const neededValues = [...sequence];
                        let canFormSequence = true;
                        
                        // ä¸ºåºåˆ—ä¸­çš„æ¯ä¸ªå€¼æ‰¾ä¸€ä¸ªéª°å­
                        for (let j = 0; j < sequence.length; j++) {
                            const targetValue = sequence[j];
                            let found = false;
                            
                            for (let k = 0; k < diceCount; k++) {
                                if (!usedIndices.has(diceIndices[k]) && !neededIndices.has(diceIndices[k]) && 
                                    diceValues[k] === targetValue) {
                                    neededIndices.add(diceIndices[k]);
                                    found = true;
                                    break;
                                }
                            }
                            
                            if (!found) {
                                canFormSequence = false;
                                break;
                            }
                        }
                        
                        if (canFormSequence && neededIndices.size === sequence.length) {
                            const newUsedIndices = new Set([...usedIndices, ...neededIndices]);
                            const newSet = [...currentSet, {
                                type: 'sequence',
                                values: sequence,
                                score: calculateScore('sequence', sequence.length),
                                indices: Array.from(neededIndices),
                                diceUsed: sequence.length
                            }];
                            
                            searchCombinations(newSet, newUsedIndices, currentScore + calculateScore('sequence', sequence.length), i + 1);
                        }
                    }
                    
                    // 2. å°è¯•å æ•°ç»„åˆ
                    // ç»Ÿè®¡å½“å‰å€¼åœ¨å‰©ä½™éª°å­ä¸­çš„æ•°é‡
                    const currentValue = diceValues[i];
                    let sameValueCount = 0;
                    const sameValueIndices = [];
                    
                    for (let j = 0; j < diceCount; j++) {
                        if (!usedIndices.has(diceIndices[j]) && diceValues[j] === currentValue) {
                            sameValueCount++;
                            sameValueIndices.push(diceIndices[j]);
                        }
                    }
                    
                    // å°è¯•æ‰€æœ‰å¯èƒ½çš„å æ•°å¤§å°ï¼ˆ2åˆ°7ï¼‰
                    for (let n = 2; n <= Math.min(7, sameValueCount); n++) {
                        const selectedIndices = sameValueIndices.slice(0, n);
                        const newUsedIndices = new Set([...usedIndices, ...selectedIndices]);
                        const newSet = [...currentSet, {
                            type: 'same',
                            value: currentValue,
                            count: n,
                            score: calculateScore('same', n),
                            indices: selectedIndices,
                            diceUsed: n
                        }];
                        
                        searchCombinations(newSet, newUsedIndices, currentScore + calculateScore('same', n), i + 1);
                    }
                }
            }
            
            // å¼€å§‹æœç´¢
            searchCombinations([], new Set(), 0, 0);
            
            if (allCombinationSets.length === 0) return [];
            
            // æŒ‰æ€»åˆ†æ’åºï¼Œåˆ†æ•°ç›¸åŒçš„æŒ‰ä½¿ç”¨éª°å­æ•°å¤šçš„ä¼˜å…ˆ
            allCombinationSets.sort((a, b) => {
                if (b.totalScore !== a.totalScore) return b.totalScore - a.totalScore;
                return b.totalDiceUsed - a.totalDiceUsed;
            });
            
            // è¿”å›å‰10ä¸ªæœ€ä½³ç»„åˆé›†åˆ
            return allCombinationSets.slice(0, 10);
        }
        
        // æ£€æŸ¥ç»„åˆé›†ä¸­æ˜¯å¦åŒ…å«ç‰¹å®šç±»å‹çš„ç»„åˆ
        function hasCombinationOfType(combinationSet, type, count) {
            return combinationSet.combinations.some(comb => 
                comb.type === type && 
                (type === 'sequence' ? comb.values.length === count : comb.count === count)
            );
        }
        
        // ç»Ÿè®¡ç»„åˆé›†ä¸­ç‰¹å®šç±»å‹ç»„åˆçš„æ•°é‡
        function countCombinationsOfType(combinationSet, type, count) {
            return combinationSet.combinations.filter(comb => 
                comb.type === type && 
                (type === 'sequence' ? comb.values.length === count : comb.count === count)
            ).length;
        }
        
        // æ ¹æ®ç©å®¶é¢†å…ˆåˆ†æ•°å’Œå‰©ä½™éª°å­æ•°é‡è®¡ç®—é‡æŠ•æ¦‚ç‡
        function calculateRerollChance(playerLead, remainingDice) {
            // å¦‚æœç©å®¶å·²ç»è¾¾åˆ°ç›®æ ‡åˆ†ï¼Œä¸”AIç›®å‰æœ¬å›åˆå¾—åˆ†+æ­¤å‰å¾—åˆ†è¿˜æ— æ³•è¿½å¹³ç©å®¶æ—¶ï¼šAIä¼šå°è¯•æ‰€æœ‰é‡æŠ•å¯èƒ½
            if (gameState.playerScore >= gameState.targetScore) {
                const aiPotentialTotal = gameState.aiScore + gameState.aiRoundScore;
                if (aiPotentialTotal < gameState.playerScore) {
                    return 1.0; // 100%é‡æŠ•
                }
            }
            
            // å½“aiç›®å‰æœ¬å›åˆå¾—åˆ†+æ­¤å‰å¾—åˆ†å·²ç»è¶…è¿‡ç©å®¶æ—¶ï¼Œåˆ™è¦å›åˆ°æ™®é€šç­–ç•¥
            const aiPotentialTotal = gameState.aiScore + gameState.aiRoundScore;
            if (aiPotentialTotal > gameState.playerScore) {
                // ä½¿ç”¨æ™®é€šç­–ç•¥ï¼ˆåŸºäºé¢†å…ˆåˆ†æ•°ï¼‰
                if (playerLead <= 100) {
                    if (remainingDice >= 4) return 1.0;
                    else if (remainingDice <= 3) return 0.0;
                } else if (playerLead <= 200) {
                    if (remainingDice >= 4) return 1.0;
                    else if (remainingDice === 3) return 0.3;
                    else if (remainingDice === 2) return 0.1;
                } else if (playerLead > 200) {
                    if (remainingDice >= 4) return 1.0;
                    else if (remainingDice === 3) return 0.5;
                    else if (remainingDice === 2) return 0.2;
                }
            } else {
                // AIè½åæˆ–å¹³å±€æ—¶ï¼Œä½¿ç”¨è¿½åˆ†ç­–ç•¥
                if (playerLead <= 100) {
                    if (remainingDice >= 4) return 1.0;
                    else if (remainingDice <= 3) return 0.0;
                } else if (playerLead <= 200) {
                    if (remainingDice >= 4) return 1.0;
                    else if (remainingDice === 3) return 0.3;
                    else if (remainingDice === 2) return 0.1;
                } else if (playerLead > 200) {
                    if (remainingDice >= 4) return 1.0;
                    else if (remainingDice === 3) return 0.5;
                    else if (remainingDice === 2) return 0.2;
                }
            }
            
            return 0.0; // é»˜è®¤ä¸é‡æŠ•
        }
        
        // æ–°ç­–ç•¥ï¼š7ä¸ªéª°å­æ—¶çš„AIç­–ç•¥ - ä¿®å¤2å ã€3è¿æˆ–3å é—®é¢˜
        function selectCombinationForSevenDice(availableDice) {
            const allCombinationSets = findAllValidCombinationsForAI(availableDice);
            
            if (allCombinationSets.length === 0) return null;
            
            // æ£€æŸ¥æ‰€æœ‰ç»„åˆé›†ï¼Œä¼˜å…ˆé€‰æ‹©ç¬¦åˆè¦æ±‚çš„ç»„åˆ
            for (const set of allCombinationSets) {
                const combinations = set.combinations;
                
                // å¦‚æœåªæœ‰ä¸€ä¸ªç»„åˆ
                if (combinations.length === 1) {
                    const comb = combinations[0];
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯2å ã€3è¿æˆ–3å 
                    const isTwoSame = comb.type === 'same' && comb.count === 2;
                    const isThreeSequence = comb.type === 'sequence' && comb.values.length === 3;
                    const isThreeSame = comb.type === 'same' && comb.count === 3; // æ–°å¢ï¼š3å 
                    
                    // å¦‚æœæ˜¯2å ã€3è¿æˆ–3å ï¼Œç›´æ¥é€‰æ‹©è¿™ä¸ªç»„åˆ
                    if (isTwoSame || isThreeSequence || isThreeSame) {
                        return set;
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰5ä¸ªéª°å­æœ‰æ•ˆç»„åˆï¼ˆ5å ã€5è¿ï¼‰æˆ–ä»¥ä¸Šç»„åˆ
                const hasLargeCombination = set.combinations.some(comb => 
                    (comb.type === 'same' && comb.count >= 5) || 
                    (comb.type === 'sequence' && comb.values.length >= 5)
                );
                
                if (hasLargeCombination) {
                    return set;
                }
            }
            
            // å¦‚æœæ²¡æœ‰2å /3è¿/3å æˆ–å¤§ç»„åˆï¼Œå¯»æ‰¾èƒ½æ¸…ç©ºéª°å­çš„ç»„åˆ
            for (const set of allCombinationSets) {
                if (set.totalDiceUsed === 7) {
                    return set;
                }
            }
            
            // å¯»æ‰¾4å 
            for (const set of allCombinationSets) {
                if (hasCombinationOfType(set, 'same', 4)) {
                    return set;
                }
            }
            
            // å¯»æ‰¾ä¸¤ä¸ª3å 
            for (const set of allCombinationSets) {
                if (countCombinationsOfType(set, 'same', 3) >= 2) {
                    return set;
                }
            }
            
            // å¯»æ‰¾4è¿
            for (const set of allCombinationSets) {
                if (hasCombinationOfType(set, 'sequence', 4)) {
                    return set;
                }
            }
            
            // å¯»æ‰¾3å +3è¿
            for (const set of allCombinationSets) {
                const hasThreeSame = hasCombinationOfType(set, 'same', 3);
                const hasThreeSequence = hasCombinationOfType(set, 'sequence', 3);
                
                if (hasThreeSame && hasThreeSequence) {
                    return set;
                }
            }
            
            // å¦‚æœä»¥ä¸Šéƒ½æ²¡æœ‰ï¼Œå°è¯•æ‰¾åˆ°ä¸€ä¸ª3å ã€3è¿æˆ–2å ï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼š3å  > 3è¿ > 2å ï¼‰
            
            // é¦–å…ˆå°è¯•æ‰¾3å ï¼ˆæ–°å¢ï¼šæœ€é«˜ä¼˜å…ˆçº§ï¼‰
            const valueCounts = {};
            availableDice.forEach(dice => valueCounts[dice.value] = (valueCounts[dice.value] || 0) + 1);
            
            for (const value in valueCounts) {
                if (valueCounts[value] >= 3) {
                    // æ‰¾åˆ°3å çš„ç»„åˆ
                    const indices = availableDice.filter(d => d.value == value).slice(0, 3).map(d => d.index);
                    return {
                        combinations: [{
                            type: 'same',
                            value: parseInt(value),
                            count: 3,
                            score: calculateScore('same', 3),
                            indices: indices,
                            diceUsed: 3
                        }],
                        totalScore: calculateScore('same', 3),
                        totalDiceUsed: 3
                    };
                }
            }
            
            // å¦‚æœæ²¡æœ‰3å ï¼Œå°è¯•æ‰¾3è¿ï¼ˆä¼˜å…ˆçº§ç¬¬äºŒï¼‰
            const uniqueValues = [...new Set(availableDice.map(d => d.value))].sort((a, b) => a - b);
            for (let i = 0; i <= uniqueValues.length - 3; i++) {
                if (uniqueValues[i] + 1 === uniqueValues[i+1] && uniqueValues[i] + 2 === uniqueValues[i+2]) {
                    // æ‰¾åˆ°3è¿çš„ç»„åˆ
                    const indices = [];
                    for (let j = 0; j < 3; j++) {
                        const targetValue = uniqueValues[i] + j;
                        const dice = availableDice.find(d => d.value === targetValue);
                        if (dice) indices.push(dice.index);
                    }
                    if (indices.length === 3) {
                        return {
                            combinations: [{
                                type: 'sequence',
                                values: [uniqueValues[i], uniqueValues[i]+1, uniqueValues[i]+2],
                                score: calculateScore('sequence', 3),
                                indices: indices,
                                diceUsed: 3
                            }],
                            totalScore: calculateScore('sequence', 3),
                            totalDiceUsed: 3
                        };
                    }
                }
            }
            
            // å¦‚æœæ²¡æœ‰3è¿ï¼Œæœ€åå°è¯•æ‰¾2å ï¼ˆä¼˜å…ˆçº§æœ€ä½ï¼‰
            for (const value in valueCounts) {
                if (valueCounts[value] >= 2) {
                    // æ‰¾åˆ°2å çš„ç»„åˆ
                    const indices = availableDice.filter(d => d.value == value).slice(0, 2).map(d => d.index);
                    return {
                        combinations: [{
                            type: 'same',
                            value: parseInt(value),
                            count: 2,
                            score: calculateScore('same', 2),
                            indices: indices,
                            diceUsed: 2
                        }],
                        totalScore: calculateScore('same', 2),
                        totalDiceUsed: 2
                    };
                }
            }
            
            // å¦‚æœéƒ½æ²¡æœ‰ï¼Œè¿”å›ç¬¬ä¸€ä¸ªç»„åˆé›†
            return allCombinationSets[0];
        }
        
        // AIé€‰æ‹©ç»„åˆ - ä½¿ç”¨ä¿®æ”¹åçš„ç­–ç•¥
        function aiSelectCombination() {
            if (!gameState.gameActive || gameState.currentPlayer !== 'ai') return;
            
            const availableDice = [];
            for (let i = 0; i < gameState.diceCount; i++) {
                if (!gameState.selectedDice.includes(i)) {
                    availableDice.push({index: i, value: gameState.diceValues[i]});
                }
            }
            
            // å¦‚æœå¯ç”¨éª°å­æ•°é‡ä¸º7ï¼Œä½¿ç”¨æ–°ç­–ç•¥
            if (availableDice.length === 7) {
                const selectedSet = selectCombinationForSevenDice(availableDice);
                
                if (selectedSet && selectedSet.combinations.length > 0) {
                    const selectedCombinations = selectedSet.combinations;
                    
                    // å°†æ‰€æœ‰ç»„åˆçš„éª°å­ç´¢å¼•åˆå¹¶
                    const allIndices = selectedCombinations.flatMap(comb => comb.indices);
                    
                    // è®¾ç½®å½“å‰ç»„åˆå’Œé€‰æ‹©çš„éª°å­
                    gameState.currentCombination = selectedCombinations.map(comb => ({
                        type: comb.type,
                        value: comb.value,
                        values: comb.values,
                        count: comb.count,
                        score: comb.score,
                        indices: comb.indices
                    }));
                    
                    gameState.currentSequence = allIndices;
                    
                    // æ¨¡æ‹ŸAIç‚¹å‡»éª°å­
                    simulateAIDiceSelection(allIndices);
                    
                    // å†³ç­–é€»è¾‘ï¼šæ ¹æ®ç©å®¶é¢†å…ˆåˆ†æ•°å’Œå‰©ä½™éª°å­æ•°é‡å†³å®šæ˜¯å¦é‡æŠ•
                    const diceLeftAfterSelection = availableDice.length - allIndices.length;
                    
                    let shouldContinue = false;
                    
                    // ç‰¹æ®Šæƒ…å†µå¤„ç†
                    if (allIndices.length === availableDice.length) {
                        // æƒ…å†µ1ï¼šå…¨æ¸…éª°å­ï¼ˆå‰©ä½™0ä¸ªï¼‰â†’ å¿…é¡»ç»§ç»­ï¼ˆå¥–åŠ±é‡æŠ•ï¼‰
                        shouldContinue = true;
                    }
                    else if (diceLeftAfterSelection === 1) {
                        // æƒ…å†µ2ï¼šåªå‰©1ä¸ªéª°å­ â†’ å¿…é¡»ç»“æŸï¼ˆè§„åˆ™ç¦æ­¢ç»§ç»­ï¼‰
                        shouldContinue = false;
                    }
                    else {
                        // å…¶ä»–æƒ…å†µï¼šæ ¹æ®è¿½åˆ†ç­–ç•¥å†³ç­–
                        const playerLead = gameState.playerScore - gameState.aiScore;
                        
                        // å…³é”®ä¿®å¤ï¼šå½“æœ‰7ä¸ªéª°å­ä¸”é€‰æ‹©äº†2å ã€3è¿æˆ–3å æ—¶ï¼Œå¦‚æœå‰©ä½™éª°å­>=4ï¼Œ100%é‡æŠ•
                        const isSingleTwoSame = selectedCombinations.length === 1 && 
                                              selectedCombinations[0].type === 'same' && 
                                              selectedCombinations[0].count === 2;
                        const isSingleThreeSequence = selectedCombinations.length === 1 && 
                                                    selectedCombinations[0].type === 'sequence' && 
                                                    selectedCombinations[0].values.length === 3;
                        const isSingleThreeSame = selectedCombinations.length === 1 &&  // æ–°å¢ï¼š3å 
                                                selectedCombinations[0].type === 'same' && 
                                                selectedCombinations[0].count === 3;
                        
                        if ((isSingleTwoSame || isSingleThreeSequence || isSingleThreeSame) && diceLeftAfterSelection >= 4) {
                            // åœºä¸Šæœ‰7ä¸ªéª°å­ä¸”AIé€‰æ‹©äº†2å ã€3è¿æˆ–3å æ—¶ï¼Œå‰©ä½™éª°å­å¤§äºç­‰äº4ä¸ªï¼Œ100%é‡æŠ•
                            shouldContinue = true;
                        } else {
                            // ä½¿ç”¨è¿½åˆ†ç­–ç•¥
                            const rerollChance = calculateRerollChance(playerLead, diceLeftAfterSelection);
                            shouldContinue = Math.random() < rerollChance;
                        }
                    }
                    
                    setTimeout(() => {
                        if (shouldContinue) {
                            setTimeout(() => confirmAndContinue(), 800);
                        } else {
                            setTimeout(() => confirmAndEnd(), 800);
                        }
                    }, 1800);
                } else {
                    gameState.currentAICombinationString = 'æ— æœ‰æ•ˆç»„åˆ';
                    setTimeout(() => endRound(), 1500);
                }
            } else {
                // å¯ç”¨éª°å­æ•°é‡å°‘äº7ï¼Œä½¿ç”¨è¿½åˆ†ç­–ç•¥
                const allCombinationSets = findAllValidCombinationsForAI(availableDice);
                
                if (allCombinationSets.length > 0 && allCombinationSets[0].combinations.length > 0) {
                    const bestSet = allCombinationSets[0];
                    const selectedCombinations = bestSet.combinations;
                    
                    // å°†æ‰€æœ‰ç»„åˆçš„éª°å­ç´¢å¼•åˆå¹¶
                    const allIndices = selectedCombinations.flatMap(comb => comb.indices);
                    
                    // è®¾ç½®å½“å‰ç»„åˆå’Œé€‰æ‹©çš„éª°å­
                    gameState.currentCombination = selectedCombinations.map(comb => ({
                        type: comb.type,
                        value: comb.value,
                        values: comb.values,
                        count: comb.count,
                        score: comb.score,
                        indices: comb.indices
                    }));
                    
                    gameState.currentSequence = allIndices;
                    
                    // æ¨¡æ‹ŸAIç‚¹å‡»éª°å­
                    simulateAIDiceSelection(allIndices);
                    
                    // å†³ç­–é€»è¾‘ï¼šæ ¹æ®ç©å®¶é¢†å…ˆåˆ†æ•°å’Œå‰©ä½™éª°å­æ•°é‡å†³å®šæ˜¯å¦é‡æŠ•
                    let shouldContinue = false;
                    const diceLeftAfterSelection = availableDice.length - allIndices.length;
                    
                    // ç‰¹æ®Šæƒ…å†µå¤„ç†
                    if (allIndices.length === availableDice.length) {
                        // æƒ…å†µ1ï¼šå…¨æ¸…éª°å­ï¼ˆå‰©ä½™0ä¸ªï¼‰â†’ å¿…é¡»ç»§ç»­ï¼ˆå¥–åŠ±é‡æŠ•ï¼‰
                        shouldContinue = true;
                    }
                    else if (diceLeftAfterSelection === 1) {
                        // æƒ…å†µ2ï¼šåªå‰©1ä¸ªéª°å­ â†’ å¿…é¡»ç»“æŸï¼ˆè§„åˆ™ç¦æ­¢ç»§ç»­ï¼‰
                        shouldContinue = false;
                    }
                    else {
                        // å…¶ä»–æƒ…å†µï¼šæ ¹æ®è¿½åˆ†ç­–ç•¥å†³ç­–
                        const playerLead = gameState.playerScore - gameState.aiScore;
                        const rerollChance = calculateRerollChance(playerLead, diceLeftAfterSelection);
                        shouldContinue = Math.random() < rerollChance;
                    }
                    
                    setTimeout(() => {
                        if (shouldContinue) {
                            setTimeout(() => confirmAndContinue(), 800);
                        } else {
                            setTimeout(() => confirmAndEnd(), 800);
                        }
                    }, 1800);
                } else {
                    gameState.currentAICombinationString = 'æ— æœ‰æ•ˆç»„åˆ';
                    setTimeout(() => endRound(), 1500);
                }
            }
        }
        
        // æ¨¡æ‹ŸAIç‚¹å‡»éª°å­
        function simulateAIDiceSelection(indices) {
            indices.forEach(index => {
                const diceElement = document.querySelector(`.dice[data-index="${index}"]`);
                if (diceElement) {
                    diceElement.classList.remove('selected');
                    diceElement.classList.add('ai-selected');
                }
            });
            
            setTimeout(() => {
                updateScoreTableHighlight();
                playSound('diceSelect');
            }, 1000);
        }
        
        // ç¦ç”¨æ‰€æœ‰æŒ‰é’®
        function disableAllButtons() {
            elements.confirmContinueBtn.disabled = true;
            elements.confirmEndBtn.disabled = true;
        }
        
        // æ›´æ–°åˆ†æ•°æ˜¾ç¤º
        function updateScores() {
            elements.playerScore.textContent = gameState.playerScore;
            elements.aiScore.textContent = gameState.aiScore;
            elements.targetScore.textContent = gameState.targetScore;
        }
        
        // æ›´æ–°å›åˆåˆ†æ•°æ˜¾ç¤º
        function updateRoundScoreDisplay() {
            if (gameState.currentPlayer === 'player') {
                elements.playerRoundScore.textContent = `æœ¬å›åˆ: ${gameState.roundScore}`;
                elements.aiRoundScore.textContent = `æœ¬å›åˆ: ${gameState.currentRound > 1 ? gameState.aiRoundScore : 0}`;
            } else {
                elements.playerRoundScore.textContent = `æœ¬å›åˆ: ${gameState.playerRoundScore}`;
                elements.aiRoundScore.textContent = `æœ¬å›åˆ: ${gameState.roundScore}`;
            }
        }
        
        // ============ å®Œå…¨é‡æ–°è®¾è®¡çš„å†å²è®°å½•è¡¨æ ¼æ˜¾ç¤ºå‡½æ•° ============
        function updateHistoryTable(historyData) {
            elements.historyBody.innerHTML = '';
            
            if (!historyData || !historyData.rounds || historyData.rounds.length === 0) {
                // å¦‚æœæ²¡æœ‰å†å²è®°å½•ï¼Œæ˜¾ç¤ºç©ºçŠ¶æ€
                const emptyRow = document.createElement('tr');
                const emptyCell = document.createElement('td');
                emptyCell.colSpan = 5;
                emptyCell.textContent = 'æš‚æ— å†å²è®°å½•æ•°æ®';
                emptyCell.style.textAlign = 'center';
                emptyCell.style.padding = '20px';
                emptyCell.style.color = '#888';
                emptyRow.appendChild(emptyCell);
                elements.historyBody.appendChild(emptyRow);
                return;
            }
            
            // æŒ‰å›åˆæ˜¾ç¤ºï¼Œæ¯ä¸ªå›åˆæ˜¾ç¤ºä¸¤è¡Œï¼šç¬¬ä¸€è¡Œç©å®¶ï¼Œç¬¬äºŒè¡ŒAI
            historyData.rounds.forEach((round, index) => {
                // ç©å®¶è¡Œ
                const playerRow = document.createElement('tr');
                playerRow.className = 'player-row';
                
                // å›åˆå•å…ƒæ ¼ï¼ˆåˆå¹¶ä¸¤è¡Œï¼‰
                const roundCell = document.createElement('td');
                roundCell.className = 'round-number-cell';
                roundCell.rowSpan = 2;
                roundCell.textContent = round.round;
                playerRow.appendChild(roundCell);
                
                // ç©å®¶å•å…ƒæ ¼
                const playerNameCell = document.createElement('td');
                playerNameCell.textContent = 'ç©å®¶';
                playerRow.appendChild(playerNameCell);
                
                // ç»„åˆè¯¦æƒ…
                const playerComboCell = document.createElement('td');
                playerComboCell.textContent = round.playerPenalty ? 'æƒ©ç½šå½’é›¶' : round.playerCombination;
                playerRow.appendChild(playerComboCell);
                
                // å¾—åˆ†
                const playerScoreCell = document.createElement('td');
                playerScoreCell.textContent = round.playerPenalty ? 0 : round.playerScore;
                playerRow.appendChild(playerScoreCell);
                
                // ç´¯è®¡åˆ†æ•°
                const playerCumulativeCell = document.createElement('td');
                playerCumulativeCell.textContent = round.playerCumulativeScore;
                playerRow.appendChild(playerCumulativeCell);
                
                elements.historyBody.appendChild(playerRow);
                
                // AIè¡Œ
                const aiRow = document.createElement('tr');
                aiRow.className = 'ai-row';
                
                // AIåç§°ï¼ˆå›åˆå•å…ƒæ ¼å·²è¢«ç©å®¶è¡Œé€šè¿‡rowSpan=2åˆå¹¶ï¼Œæ‰€ä»¥AIè¡Œä¸éœ€è¦å›åˆå•å…ƒæ ¼ï¼‰
                const aiNameCell = document.createElement('td');
                aiNameCell.textContent = 'AI';
                aiRow.appendChild(aiNameCell);
                
                // ç»„åˆè¯¦æƒ…
                const aiComboCell = document.createElement('td');
                aiComboCell.textContent = round.aiPenalty ? 'æƒ©ç½šå½’é›¶' : round.aiCombination;
                aiRow.appendChild(aiComboCell);
                
                // å¾—åˆ†
                const aiScoreCell = document.createElement('td');
                aiScoreCell.textContent = round.aiPenalty ? 0 : round.aiScore;
                aiRow.appendChild(aiScoreCell);
                
                // ç´¯è®¡åˆ†æ•°
                const aiCumulativeCell = document.createElement('td');
                aiCumulativeCell.textContent = round.aiCumulativeScore;
                aiRow.appendChild(aiCumulativeCell);
                
                elements.historyBody.appendChild(aiRow);
                
                // åœ¨å›åˆä¹‹é—´æ·»åŠ åˆ†éš”è¡Œï¼ˆå¯é€‰ï¼Œæ·»åŠ æ›´æ˜æ˜¾çš„è§†è§‰åˆ†éš”ï¼‰
                if (index < historyData.rounds.length - 1) {
                    const spacerRow = document.createElement('tr');
                    const spacerCell = document.createElement('td');
                    spacerCell.colSpan = 5;
                    spacerCell.style.height = '8px';
                    spacerCell.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';
                    spacerCell.style.border = 'none';
                    spacerRow.appendChild(spacerCell);
                    elements.historyBody.appendChild(spacerRow);
                }
            });
        }
        
        // æ›´æ–°å†å²è®°å½•å¯¼èˆª
        function updateHistoryNav() {
            const currentHistory = historyManager.getCurrentHistory();
            const historyCount = historyManager.getHistoryCount();
            
            // æ›´æ–°å¯¼èˆªæŒ‰é’®çŠ¶æ€
            elements.historyLeftBtn.disabled = historyCount <= 1;
            elements.historyRightBtn.disabled = historyCount <= 1;
            
            if (historyCount === 0) {
                elements.historyTimeDisplay.textContent = 'æš‚æ— å†å²è®°å½•';
                elements.historyTimeDisplay.style.color = '#888';
            } else {
                // æ›´æ–°æ—¶é—´æ˜¾ç¤º
                elements.historyTimeDisplay.textContent = currentHistory.date;
                elements.historyTimeDisplay.style.color = '#ffd166';
                
                // æ˜¾ç¤ºå½“å‰è®°å½•ä½ç½®ï¼ˆå¦‚ï¼š1/3ï¼‰
                const positionDisplay = ` (${historyManager.currentHistoryIndex + 1}/${historyCount})`;
                elements.historyTimeDisplay.textContent += positionDisplay;
            }
        }
        
        // æ‰“å¼€å†å²è®°å½•å¼¹çª—
        function openHistoryModal() {
            // å¦‚æœæ¸¸æˆæ­£åœ¨è¿›è¡Œä¸­ï¼Œè®¾ç½®å½“å‰æ¸¸æˆå†å²è®°å½•
            if (gameState.gameActive && gameState.gameHistory.length > 0) {
                const totalRounds = gameState.gameHistory.length;
                const playerTotalScore = gameState.gameHistory.reduce((sum, round) => sum + round.playerScore, 0);
                const aiTotalScore = gameState.gameHistory.reduce((sum, round) => sum + round.aiScore, 0);
                const playerAvgScore = totalRounds > 0 ? Math.round(playerTotalScore / totalRounds) : 0;
                const aiAvgScore = totalRounds > 0 ? Math.round(aiTotalScore / totalRounds) : 0;
                const playerMaxScore = totalRounds > 0 ? Math.max(...gameState.gameHistory.map(round => round.playerScore)) : 0;
                const aiMaxScore = totalRounds > 0 ? Math.max(...gameState.gameHistory.map(round => round.aiScore)) : 0;
                
                historyManager.setCurrentGameHistory({
                    playerScore: gameState.playerScore,
                    aiScore: gameState.aiScore,
                    winner: gameState.gameActive ? 'playing' : 'none',
                    winnerText: gameState.gameActive ? 'æ¸¸æˆä¸­' : 'æœªå®Œæˆ',
                    totalRounds: totalRounds,
                    playerAvgScore: playerAvgScore,
                    aiAvgScore: aiAvgScore,
                    playerMaxScore: playerMaxScore,
                    aiMaxScore: aiMaxScore,
                    playerFullClear: gameState.playerFullClearCount,
                    aiFullClear: gameState.aiFullClearCount,
                    rounds: [...gameState.gameHistory]
                });
            }
            
            // é‡ç½®åˆ°ç¬¬ä¸€ä¸ªå†å²è®°å½•
            historyManager.resetToFirst();
            
            // æ›´æ–°å†å²è®°å½•å¯¼èˆª
            updateHistoryNav();
            
            // æ›´æ–°è¡¨æ ¼æ˜¾ç¤º
            const currentHistory = historyManager.getCurrentHistory();
            updateHistoryTable(currentHistory);
            
            // æ˜¾ç¤ºå¼¹çª—
            elements.historyOverlay.style.display = 'flex';
            document.getElementById('history-close-hint').style.display = 'block';
        }
        
        // å¯¼èˆªåˆ°ä¸Šä¸€ä¸ªå†å²è®°å½•
        function navigateToPrevHistory() {
            const history = historyManager.getPrevHistory();
            updateHistoryTable(history);
            updateHistoryNav();
            playSound('buttonClick');
        }
        
        // å¯¼èˆªåˆ°ä¸‹ä¸€ä¸ªå†å²è®°å½•
        function navigateToNextHistory() {
            const history = historyManager.getNextHistory();
            updateHistoryTable(history);
            updateHistoryNav();
            playSound('buttonClick');
        }
        
        // æ›´æ–°æ¸¸æˆç»“æŸç•Œé¢ç»Ÿè®¡ä¿¡æ¯
        function updateGameOverStats() {
            elements.finalPlayerScore.textContent = gameState.playerScore;
            elements.finalAiScore.textContent = gameState.aiScore;
            const totalRounds = gameState.gameHistory.length;
            
            elements.totalRoundsDisplay.textContent = `æ€»å›åˆæ•°: ${totalRounds}`;
            
            if (totalRounds > 0) {
                const playerTotalScore = gameState.gameHistory.reduce((sum, round) => sum + round.playerScore, 0);
                elements.playerAvgScore.textContent = Math.round(playerTotalScore / totalRounds);
                elements.playerMaxScore.textContent = Math.max(...gameState.gameHistory.map(round => round.playerScore));
                
                const aiTotalScore = gameState.gameHistory.reduce((sum, round) => sum + round.aiScore, 0);
                elements.aiAvgScore.textContent = Math.round(aiTotalScore / totalRounds);
                elements.aiMaxScore.textContent = Math.max(...gameState.gameHistory.map(round => round.aiScore));
            } else {
                elements.playerAvgScore.textContent = 0;
                elements.playerMaxScore.textContent = 0;
                elements.aiAvgScore.textContent = 0;
                elements.aiMaxScore.textContent = 0;
            }
            
            // æ›´æ–°ç»Ÿè®¡é¡¹
            elements.playerFullClear.textContent = gameState.playerFullClearCount;
            elements.aiFullClear.textContent = gameState.aiFullClearCount;
        }
        
        // ç»“æŸæ¸¸æˆ
        function endGame(winner, winnerText) {
            gameState.gameActive = false;
            updateGameOverStats();
            elements.gameOverElement.style.display = 'flex';
            
            // è®¾ç½®è·èƒœæ¶ˆæ¯
            elements.winnerText.textContent = winnerText;
            
            if (winner === 'player') {
                elements.winnerMessage.className = 'winner-message player-winner';
                setTimeout(() => playSound('win'), 500);
            } else if (winner === 'ai') {
                elements.winnerMessage.className = 'winner-message ai-winner';
                setTimeout(() => playSound('lose'), 500);
            } else {
                elements.winnerMessage.className = 'winner-message tie-winner';
                setTimeout(() => playSound('score'), 500);
            }
            
            // ä¿å­˜å½“å‰æ¸¸æˆå†å²è®°å½•åˆ°å­˜å‚¨åˆ—è¡¨
            const totalRounds = gameState.gameHistory.length;
            const playerTotalScore = totalRounds > 0 ? 
                gameState.gameHistory.reduce((sum, round) => sum + round.playerScore, 0) : 0;
            const aiTotalScore = totalRounds > 0 ? 
                gameState.gameHistory.reduce((sum, round) => sum + round.aiScore, 0) : 0;
            const playerAvgScore = totalRounds > 0 ? Math.round(playerTotalScore / totalRounds) : 0;
            const aiAvgScore = totalRounds > 0 ? Math.round(aiTotalScore / totalRounds) : 0;
            const playerMaxScore = totalRounds > 0 ? 
                Math.max(...gameState.gameHistory.map(round => round.playerScore)) : 0;
            const aiMaxScore = totalRounds > 0 ? 
                Math.max(...gameState.gameHistory.map(round => round.aiScore)) : 0;
            
            // ä¿å­˜åˆ°å†å²è®°å½•ç®¡ç†å™¨
            historyManager.addHistory({
                playerScore: gameState.playerScore,
                aiScore: gameState.aiScore,
                winner: winner,
                winnerText: winnerText,
                totalRounds: totalRounds,
                playerAvgScore: playerAvgScore,
                aiAvgScore: aiAvgScore,
                playerMaxScore: playerMaxScore,
                aiMaxScore: aiMaxScore,
                playerFullClear: gameState.playerFullClearCount,
                aiFullClear: gameState.aiFullClearCount,
                rounds: [...gameState.gameHistory]
            });
        }
        
        // äº‹ä»¶ç›‘å¬
        elements.confirmContinueBtn.addEventListener('click', confirmAndContinue);
        elements.confirmEndBtn.addEventListener('click', confirmAndEnd);
        elements.restartBtn.addEventListener('click', initGame);
        
        // å†å²è®°å½•å¯¼èˆªæŒ‰é’®äº‹ä»¶ç›‘å¬
        elements.historyLeftBtn.addEventListener('click', navigateToPrevHistory);
        elements.historyRightBtn.addEventListener('click', navigateToNextHistory);
        
        // åˆå§‹åŒ–æ¸¸æˆå’Œè®¡åˆ†è¡¨
        initGame();
    </script>
</body>
</html>
